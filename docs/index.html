<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Nidish Narayanaa Balaji" />
  <title>An ABAQUS-MATLAB tutorial for Jointed Systems</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <base target="_blank">
</head>
<body>
<header id="title-block-header">
<h1 class="title">An ABAQUS-MATLAB tutorial for Jointed Systems</h1>
<p class="author">Nidish Narayanaa Balaji</p>
</header>
<style> summary:hover {background:pink;} </style>
<script>var HS_STARTUP_FOLDED = true;</script>
<h1 id="preprocess">Preprocess</h1>
<p>The Brake-Reuß Beam (BRB) is a 3-bolted lap-joint beam which will
serve as our tutorial joint structure (read more about the benchmark <a
href="https://jointmechanics.org/index.php/Benchmarks#The_Brake-Reu%C3%9F_Beams">here</a>).
To make the tutorial self-contained, the tutorial will begin with
CAD-modeling of the BRB in ABAQUS and take you all the way to matrix
extraction and nonlinear dynamics analysis on MATLAB/OCTAVE. Buckle up!
:)</p>
<figure>
<img src="./figs/300px-BRB.png" title="brbgeom" class="zoomable-image"
data-align="center" width="300" alt="Geometry of the BRB Benchmark" />
<figcaption aria-hidden="true">Geometry of the BRB
Benchmark</figcaption>
</figure>
<p>A picture of the parts of the BRB is shown in Fig. <a
href="#fig:brbgeom">1</a> and this will be used to guide the modeling
here. Standard 5/16 bolt-nut-washers will be used for the assembly.
Since Bolt thread interactions won't be modeled here, the bolt shank is
modeled as a smooth cylinder (see <a href="#sec:boltprel">2.2</a> for
more details on bolt prestress modeling).</p>
<p><strong>Note</strong>: If you already have a model of your structure
and want to just apply the node-selection/matrix extraction, you can
safely ignore the sections particular to the modeling of the BRB and
just go through the remaining, whose instructions are quite general. The
general principles in the modeling section are, however, recommended for
all jointed structure modeling.</p>
<h2 id="a-note-on-python-scripting">A Note on Python Scripting <span
class="tag" data-tag-name="Script"><span
class="smallcaps">Script</span></span></h2>
<p>ABAQUS Python scripting is quite powerful and will be used quite
liberally throughout this tutorial. The following are some tips/tricks
to get started for beginners:</p>
<ul>
<li>For beginners, the easiest way to start scripting is to open up CAE
(the GUI) and do the necessary tasks. ABAQUS would have saved the
actions in a Python file called <code
class="verbatim">abaqus.rpy</code>. This is just python code that can be
imported into ABAQUS to repeat the same tasks. All standard python
commands work so this makes it very helpful.</li>
<li>On Windows the <strong>work directory</strong> may be an unfamiliar
concept (on Linux it is just the directory from which ABAQUS is
launched). This directory can be manually set by
<code>File-&gt;Set Work Directory</code>, following which all the files
(including the <code class="verbatim">ABAQUS.rpy</code> file) will be
put in the specified folder.</li>
<li>Fig <a href="#fig:ovw">2</a> shows a pictorial overview of the
different options available in ABAQUS for scripting support. The ABAQUS
PDE can be used for ABAQUS python script development.</li>
</ul>
<figure>
<img src="./figs/ovw.png" title="ovw" class="zoomable-image"
data-align="center" width="600" alt="Options in ABAQUS for Scripting" />
<figcaption aria-hidden="true">Options in ABAQUS for
Scripting</figcaption>
</figure>
<h2 id="modeling-parts">Modeling Parts <span class="tag"
data-tag-name="Script"><span
class="smallcaps">Script</span></span> <span class="tag"
data-tag-name="GUI"><span class="smallcaps">GUI</span></span></h2>
<p>We will first model the two "halves" of the BRB. The following steps
enumerate the process (can be skipped if you already have a model).</p>
<p>We will do the construction through ABAQUS Python code that can be
imported through <code class="verbatim">File-&gt;Run Script</code> or
just typed into the command line.</p>
<ol>
<li><p>First import the following code to import all the necessary
objects and then the material properties (steel, here).</p>
<div class="sourceCode" id="cb1" data-startFrom=""><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># -*- coding: utf-8 -*-</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> sys</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="im">from</span> part <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="im">from</span> material <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="im">from</span> section <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="im">from</span> assembly <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="im">from</span> step <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="im">from</span> interaction <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="im">from</span> load <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="im">from</span> mesh <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="im">from</span> optimization <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="im">from</span> job <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="im">from</span> sketch <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="im">from</span> visualization <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="im">from</span> connectorBehavior <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-17"><a href="#cb1-17"></a></span>
<span id="cb1-18"><a href="#cb1-18"></a>mdl <span class="op">=</span> mdb.models[<span class="st">&#39;Model-1&#39;</span>]</span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="co">##############################</span></span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="co"># MATERIAL PROPERTIES: STEEL #</span></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="co">##############################</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>mdl.Material(name<span class="op">=</span><span class="st">&#39;STEEL&#39;</span>)</span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a>steel <span class="op">=</span> mdl.materials[<span class="st">&#39;STEEL&#39;</span>]</span>
<span id="cb1-25"><a href="#cb1-25"></a>steel.Density(table<span class="op">=</span>((<span class="fl">7800.0</span>, ), ))</span>
<span id="cb1-26"><a href="#cb1-26"></a>steel.Elastic(table<span class="op">=</span>((<span class="fl">2e11</span>, <span class="fl">0.29</span>),))</span>
<span id="cb1-27"><a href="#cb1-27"></a>mdl.HomogeneousSolidSection(material<span class="op">=</span><span class="st">&#39;STEEL&#39;</span>, name<span class="op">=</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>                            <span class="st">&#39;Section-1&#39;</span>, thickness<span class="op">=</span><span class="va">None</span>)</span></code></pre></div>
<p>The above code creates a new material called "STEEL", with Young's
Modulus 200GPa, Poisson's ratio 0.29, and density 7800
kg/m<sup>3</sup>.</p></li>
<li><p>Now use the following to model the half beam (this can be done on
CAE with the GUI quite easily).</p>
<div class="sourceCode" id="cb2" data-startFrom=""><pre
class="sourceCode numberSource python numberLines continuedSourceBlock"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>mdl <span class="op">=</span> mdb.models[<span class="st">&#39;Model-1&#39;</span>]</span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co">###################</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co"># PART : HALFBEAM #</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">###################</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="co"># 1. Sketch and Extrude</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>mdl.ConstrainedSketch(name<span class="op">=</span><span class="st">&#39;__profile__&#39;</span>, sheetSize<span class="op">=</span><span class="fl">2.0</span>)</span>
<span id="cb2-8"><a href="#cb2-8"></a>sktch <span class="op">=</span> mdl.sketches[<span class="st">&#39;__profile__&#39;</span>]</span>
<span id="cb2-9"><a href="#cb2-9"></a>sktch.Line(point1<span class="op">=</span>(<span class="op">-</span><span class="fl">36e-2</span>, <span class="fl">1.27e-2</span>), point2<span class="op">=</span>(<span class="op">-</span><span class="fl">6e-2</span>, <span class="fl">1.27e-2</span>))</span>
<span id="cb2-10"><a href="#cb2-10"></a>sktch.Line(point1<span class="op">=</span>(<span class="op">-</span><span class="fl">6e-2</span>, <span class="fl">1.27e-2</span>), point2<span class="op">=</span>(<span class="op">-</span><span class="fl">6e-2</span>, <span class="dv">0</span>))</span>
<span id="cb2-11"><a href="#cb2-11"></a>sktch.Line(point1<span class="op">=</span>(<span class="op">-</span><span class="fl">6e-2</span>, <span class="dv">0</span>), point2<span class="op">=</span>(<span class="fl">6e-2</span>,<span class="dv">0</span>))</span>
<span id="cb2-12"><a href="#cb2-12"></a>sktch.Line(point1<span class="op">=</span>(<span class="fl">6e-2</span>,<span class="dv">0</span>), point2<span class="op">=</span>(<span class="fl">6e-2</span>,<span class="op">-</span><span class="fl">1.27e-2</span>))</span>
<span id="cb2-13"><a href="#cb2-13"></a>sktch.Line(point1<span class="op">=</span>(<span class="fl">6e-2</span>,<span class="op">-</span><span class="fl">1.27e-2</span>), point2<span class="op">=</span>(<span class="op">-</span><span class="fl">36e-2</span>,<span class="op">-</span><span class="fl">1.27e-2</span>))</span>
<span id="cb2-14"><a href="#cb2-14"></a>sktch.Line(point1<span class="op">=</span>(<span class="op">-</span><span class="fl">36e-2</span>,<span class="op">-</span><span class="fl">1.27e-2</span>), point2<span class="op">=</span>(<span class="op">-</span><span class="fl">36e-2</span>,<span class="fl">1.27e-2</span>))</span>
<span id="cb2-15"><a href="#cb2-15"></a></span>
<span id="cb2-16"><a href="#cb2-16"></a>mdl.Part(dimensionality<span class="op">=</span>THREE_D, name<span class="op">=</span><span class="st">&#39;HALFBEAM&#39;</span>, <span class="bu">type</span><span class="op">=</span>DEFORMABLE_BODY)</span>
<span id="cb2-17"><a href="#cb2-17"></a>hfbm <span class="op">=</span> mdl.parts[<span class="st">&#39;HALFBEAM&#39;</span>]</span>
<span id="cb2-18"><a href="#cb2-18"></a>hfbm.BaseSolidExtrude(depth<span class="op">=</span><span class="fl">25.4e-3</span>, sketch<span class="op">=</span>sktch)</span>
<span id="cb2-19"><a href="#cb2-19"></a><span class="kw">del</span> sktch</span>
<span id="cb2-20"><a href="#cb2-20"></a></span>
<span id="cb2-21"><a href="#cb2-21"></a><span class="co"># 2. Cut out Holes</span></span>
<span id="cb2-22"><a href="#cb2-22"></a>mdl.ConstrainedSketch(name<span class="op">=</span><span class="st">&#39;__profile__&#39;</span>, sheetSize<span class="op">=</span><span class="fl">2.0</span>,</span>
<span id="cb2-23"><a href="#cb2-23"></a>                      transform<span class="op">=</span></span>
<span id="cb2-24"><a href="#cb2-24"></a>                      hfbm.MakeSketchTransform(</span>
<span id="cb2-25"><a href="#cb2-25"></a>                          sketchPlane<span class="op">=</span>hfbm.faces[<span class="dv">2</span>],</span>
<span id="cb2-26"><a href="#cb2-26"></a>                          sketchPlaneSide<span class="op">=</span>SIDE1,</span>
<span id="cb2-27"><a href="#cb2-27"></a>                          sketchUpEdge<span class="op">=</span>hfbm.edges[<span class="dv">8</span>],</span>
<span id="cb2-28"><a href="#cb2-28"></a>                          sketchOrientation<span class="op">=</span>RIGHT,</span>
<span id="cb2-29"><a href="#cb2-29"></a>                          origin<span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">1.27e-2</span>)))</span>
<span id="cb2-30"><a href="#cb2-30"></a>sktch <span class="op">=</span> mdl.sketches[<span class="st">&#39;__profile__&#39;</span>]</span>
<span id="cb2-31"><a href="#cb2-31"></a>cs <span class="op">=</span> [<span class="op">-</span><span class="fl">3e-2</span>, <span class="fl">0.0</span>, <span class="fl">3e-2</span>]<span class="op">;</span></span>
<span id="cb2-32"><a href="#cb2-32"></a>gs <span class="op">=</span> []</span>
<span id="cb2-33"><a href="#cb2-33"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb2-34"><a href="#cb2-34"></a>    gs.append(sktch.CircleByCenterPerimeter(center<span class="op">=</span>(cs[i], <span class="dv">0</span>),</span>
<span id="cb2-35"><a href="#cb2-35"></a>                                            point1<span class="op">=</span>(cs[i]<span class="op">+</span><span class="fl">0.85e-2</span><span class="op">/</span><span class="dv">2</span>, <span class="dv">0</span>)))</span>
<span id="cb2-36"><a href="#cb2-36"></a></span>
<span id="cb2-37"><a href="#cb2-37"></a>hfbm.CutExtrude(sketchPlane<span class="op">=</span>hfbm.faces[<span class="dv">2</span>], sketchPlaneSide<span class="op">=</span>SIDE1,</span>
<span id="cb2-38"><a href="#cb2-38"></a>                sketchUpEdge<span class="op">=</span>hfbm.edges[<span class="dv">8</span>],</span>
<span id="cb2-39"><a href="#cb2-39"></a>                sketchOrientation<span class="op">=</span>RIGHT, sketch<span class="op">=</span>sktch)</span>
<span id="cb2-40"><a href="#cb2-40"></a></span>
<span id="cb2-41"><a href="#cb2-41"></a></span>
<span id="cb2-42"><a href="#cb2-42"></a><span class="co"># 3. Partition object</span></span>
<span id="cb2-43"><a href="#cb2-43"></a>hfbm.PartitionCellByExtendFace(cells<span class="op">=</span>hfbm.cells,</span>
<span id="cb2-44"><a href="#cb2-44"></a>                               extendFace<span class="op">=</span>hfbm.faces[<span class="dv">6</span>])</span>
<span id="cb2-45"><a href="#cb2-45"></a>hfbm.PartitionCellByExtendFace(cells<span class="op">=</span>hfbm.cells,</span>
<span id="cb2-46"><a href="#cb2-46"></a>                               extendFace<span class="op">=</span>hfbm.faces[<span class="dv">7</span>])</span>
<span id="cb2-47"><a href="#cb2-47"></a></span>
<span id="cb2-48"><a href="#cb2-48"></a>mdl.ConstrainedSketch(name<span class="op">=</span><span class="st">&#39;__profile__&#39;</span>, sheetSize<span class="op">=</span><span class="fl">2.0</span>,</span>
<span id="cb2-49"><a href="#cb2-49"></a>                      gridSpacing<span class="op">=</span><span class="fl">30e-3</span>, transform<span class="op">=</span></span>
<span id="cb2-50"><a href="#cb2-50"></a>                      hfbm.MakeSketchTransform(</span>
<span id="cb2-51"><a href="#cb2-51"></a>                          sketchPlane<span class="op">=</span>hfbm.faces[<span class="dv">11</span>],</span>
<span id="cb2-52"><a href="#cb2-52"></a>                          sketchPlaneSide<span class="op">=</span>SIDE1,</span>
<span id="cb2-53"><a href="#cb2-53"></a>                          sketchUpEdge<span class="op">=</span>hfbm.edges[<span class="dv">27</span>],</span>
<span id="cb2-54"><a href="#cb2-54"></a>                          sketchOrientation<span class="op">=</span>RIGHT,</span>
<span id="cb2-55"><a href="#cb2-55"></a>                          origin<span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">1.27e-2</span>)))</span>
<span id="cb2-56"><a href="#cb2-56"></a>sktch <span class="op">=</span> mdl.sketches[<span class="st">&#39;__profile__&#39;</span>]</span>
<span id="cb2-57"><a href="#cb2-57"></a>cs <span class="op">=</span> [<span class="op">-</span><span class="fl">3e-2</span>, <span class="fl">0.0</span>, <span class="fl">3e-2</span>]<span class="op">;</span></span>
<span id="cb2-58"><a href="#cb2-58"></a>wor <span class="op">=</span> i2m<span class="op">*</span><span class="fl">0.34375</span></span>
<span id="cb2-59"><a href="#cb2-59"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb2-60"><a href="#cb2-60"></a>    sktch.CircleByCenterPerimeter(center<span class="op">=</span>(cs[i], <span class="dv">0</span>),</span>
<span id="cb2-61"><a href="#cb2-61"></a>                                  point1<span class="op">=</span>(cs[i]<span class="op">+</span>wor, <span class="dv">0</span>))</span>
<span id="cb2-62"><a href="#cb2-62"></a>hfbm.PartitionCellBySketch(cells<span class="op">=</span>hfbm.cells, sketch<span class="op">=</span>sktch,</span>
<span id="cb2-63"><a href="#cb2-63"></a>                           sketchUpEdge<span class="op">=</span>hfbm.edges[<span class="dv">27</span>],</span>
<span id="cb2-64"><a href="#cb2-64"></a>                           sketchPlane<span class="op">=</span>hfbm.faces[<span class="dv">11</span>])</span>
<span id="cb2-65"><a href="#cb2-65"></a>hfbm.PartitionCellByExtrudeEdge(cells<span class="op">=</span>hfbm.cells, edges<span class="op">=</span>hfbm.edges[<span class="dv">0</span>],</span>
<span id="cb2-66"><a href="#cb2-66"></a>                                line<span class="op">=</span>hfbm.edges[<span class="op">-</span><span class="dv">1</span>], sense<span class="op">=</span>FORWARD)</span>
<span id="cb2-67"><a href="#cb2-67"></a>hfbm.PartitionCellByExtrudeEdge(cells<span class="op">=</span>hfbm.cells, edges<span class="op">=</span>hfbm.edges[<span class="dv">3</span>],</span>
<span id="cb2-68"><a href="#cb2-68"></a>                                line<span class="op">=</span>hfbm.edges[<span class="op">-</span><span class="dv">1</span>], sense<span class="op">=</span>FORWARD)</span>
<span id="cb2-69"><a href="#cb2-69"></a>hfbm.PartitionCellByExtrudeEdge(cells<span class="op">=</span>hfbm.cells, edges<span class="op">=</span>hfbm.edges[<span class="dv">6</span>],</span>
<span id="cb2-70"><a href="#cb2-70"></a>                                line<span class="op">=</span>hfbm.edges[<span class="op">-</span><span class="dv">1</span>], sense<span class="op">=</span>FORWARD)</span>
<span id="cb2-71"><a href="#cb2-71"></a></span>
<span id="cb2-72"><a href="#cb2-72"></a>pt <span class="op">=</span> hfbm.InterestingPoint(edge<span class="op">=</span>hfbm.edges[<span class="op">-</span><span class="dv">2</span>], rule<span class="op">=</span>MIDDLE)</span>
<span id="cb2-73"><a href="#cb2-73"></a>hfbm.PartitionCellByPlanePointNormal(cells<span class="op">=</span>hfbm.cells, point<span class="op">=</span>pt,</span>
<span id="cb2-74"><a href="#cb2-74"></a>                                     normal<span class="op">=</span>hfbm.edges[<span class="op">-</span><span class="dv">2</span>])</span>
<span id="cb2-75"><a href="#cb2-75"></a></span>
<span id="cb2-76"><a href="#cb2-76"></a>pt <span class="op">=</span> hfbm.InterestingPoint(edge<span class="op">=</span>hfbm.edges[<span class="dv">75</span>], rule<span class="op">=</span>MIDDLE)</span>
<span id="cb2-77"><a href="#cb2-77"></a>hfbm.PartitionCellByPlanePointNormal(cells<span class="op">=</span>hfbm.cells, point<span class="op">=</span>pt,</span>
<span id="cb2-78"><a href="#cb2-78"></a>                                     normal<span class="op">=</span>hfbm.edges[<span class="dv">75</span>])</span>
<span id="cb2-79"><a href="#cb2-79"></a></span>
<span id="cb2-80"><a href="#cb2-80"></a>pt <span class="op">=</span> hfbm.InterestingPoint(edge<span class="op">=</span>hfbm.edges[<span class="dv">39</span>], rule<span class="op">=</span>MIDDLE)</span>
<span id="cb2-81"><a href="#cb2-81"></a>hfbm.PartitionCellByPlanePointNormal(cells<span class="op">=</span>hfbm.cells, point<span class="op">=</span>pt,</span>
<span id="cb2-82"><a href="#cb2-82"></a>                                     normal<span class="op">=</span>hfbm.edges[<span class="dv">39</span>])</span>
<span id="cb2-83"><a href="#cb2-83"></a></span>
<span id="cb2-84"><a href="#cb2-84"></a>pt <span class="op">=</span> hfbm.InterestingPoint(edge<span class="op">=</span>hfbm.edges[<span class="dv">85</span>], rule<span class="op">=</span>MIDDLE)</span>
<span id="cb2-85"><a href="#cb2-85"></a>hfbm.PartitionCellByPlanePointNormal(cells<span class="op">=</span>hfbm.cells, point<span class="op">=</span>pt,</span>
<span id="cb2-86"><a href="#cb2-86"></a>                                     normal<span class="op">=</span>hfbm.edges[<span class="dv">85</span>])</span>
<span id="cb2-87"><a href="#cb2-87"></a></span>
<span id="cb2-88"><a href="#cb2-88"></a>pt <span class="op">=</span> hfbm.InterestingPoint(edge<span class="op">=</span>hfbm.edges[<span class="dv">39</span>], rule<span class="op">=</span>MIDDLE)</span>
<span id="cb2-89"><a href="#cb2-89"></a>hfbm.PartitionCellByPlanePointNormal(cells<span class="op">=</span>hfbm.cells, point<span class="op">=</span>pt,</span>
<span id="cb2-90"><a href="#cb2-90"></a>                                     normal<span class="op">=</span>hfbm.edges[<span class="dv">39</span>])</span>
<span id="cb2-91"><a href="#cb2-91"></a></span>
<span id="cb2-92"><a href="#cb2-92"></a>pt <span class="op">=</span> hfbm.InterestingPoint(edge<span class="op">=</span>hfbm.edges[<span class="dv">41</span>], rule<span class="op">=</span>MIDDLE)</span>
<span id="cb2-93"><a href="#cb2-93"></a>hfbm.PartitionCellByPlanePointNormal(cells<span class="op">=</span>hfbm.cells, point<span class="op">=</span>pt,</span>
<span id="cb2-94"><a href="#cb2-94"></a>                                     normal<span class="op">=</span>hfbm.edges[<span class="dv">41</span>])</span>
<span id="cb2-95"><a href="#cb2-95"></a></span>
<span id="cb2-96"><a href="#cb2-96"></a>pt <span class="op">=</span> hfbm.InterestingPoint(edge<span class="op">=</span>hfbm.edges[<span class="dv">111</span>], rule<span class="op">=</span>MIDDLE)</span>
<span id="cb2-97"><a href="#cb2-97"></a>hfbm.PartitionCellByPlanePointNormal(cells<span class="op">=</span>hfbm.cells, point<span class="op">=</span>pt,</span>
<span id="cb2-98"><a href="#cb2-98"></a>                                     normal<span class="op">=</span>hfbm.edges[<span class="dv">111</span>])</span>
<span id="cb2-99"><a href="#cb2-99"></a></span>
<span id="cb2-100"><a href="#cb2-100"></a>pt <span class="op">=</span> hfbm.InterestingPoint(edge<span class="op">=</span>hfbm.edges[<span class="dv">135</span>], rule<span class="op">=</span>MIDDLE)</span>
<span id="cb2-101"><a href="#cb2-101"></a>hfbm.PartitionCellByPlanePointNormal(cells<span class="op">=</span>hfbm.cells, point<span class="op">=</span>pt,</span>
<span id="cb2-102"><a href="#cb2-102"></a>                                     normal<span class="op">=</span>hfbm.edges[<span class="dv">135</span>])</span>
<span id="cb2-103"><a href="#cb2-103"></a></span>
<span id="cb2-104"><a href="#cb2-104"></a><span class="co"># 4. Assign Material</span></span>
<span id="cb2-105"><a href="#cb2-105"></a>regn <span class="op">=</span> hfbm.Set(cells<span class="op">=</span>hfbm.cells, name<span class="op">=</span><span class="st">&#39;Set-1&#39;</span>)</span>
<span id="cb2-106"><a href="#cb2-106"></a>hfbm.SectionAssignment(region<span class="op">=</span>regn, sectionName<span class="op">=</span><span class="st">&#39;Section-1&#39;</span>)</span></code></pre></div></li>
</ol>
<p>&lt;details class="code-details" style ="padding: 1em;
background-color: #cccccc; <em>* background-color: pink; *</em>
border-radius: 15px; color: hsl(157 75%); font-size: 0.9em; box-shadow:
0.05em 0.1em 5px 0.01em #00000057;"&gt; &lt;summary&gt; &lt;strong&gt;
&lt;font face="Courier" size="3" color="black"&gt; Scripting note
&lt;/font&gt; &lt;/strong&gt; &lt;/summary&gt; You can see that certain
faces and edges were used in the above. A quick way to check which face
is what will be to use the <code class="verbatim">highlight</code>
command on the ABAQUS python console. Here is an example:</p>
<p><img src="./figs/highl.png" width="600" /></p>
<p>&lt;/details&gt; At the end of this step, you should have a
partitioned part that looks like this. The partitioning is done in this
way to help with the seeded meshing, constraint enforcement, etc.</p>
<p><img src="./figs/parthb.png" /> &lt;details class="code-details"
style ="padding: 1em; background-color: #cccccc; <em>* background-color:
pink; *</em> border-radius: 15px; color: hsl(157 75%); font-size: 0.9em;
box-shadow: 0.05em 0.1em 5px 0.01em #00000057;"&gt; &lt;summary&gt;
&lt;strong&gt; &lt;font face="Courier" size="3" color="black"&gt;
IMPORTANT! Geometry Correction Note &lt;/font&gt; &lt;/strong&gt;
&lt;/summary&gt; You have to ensure that the curved edges on the above
are, indeed, single edges. You will run into meshing issues if this is
not the case. If not, you will have to use the "Merge Edges" tool in the
Part module and individually select each edge and merge them.</p>
<p><img src="./figs/medg.png" width="600" /></p>
<p>&lt;/details&gt;</p>
<ol>
<li><p>Create a Reference Point Part called <code
class="verbatim">REFPT</code>. This will be necessary for the
application of bolt prestress (see <a href="#sec:boltprel">2.2</a>
below).</p>
<div class="sourceCode" id="cb3" data-startFrom=""><pre
class="sourceCode numberSource python numberLines continuedSourceBlock"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>rpt <span class="op">=</span> mdl.Part(name<span class="op">=</span><span class="st">&#39;REFPT&#39;</span>, dimensionality<span class="op">=</span>THREE_D, </span>
<span id="cb3-2"><a href="#cb3-2"></a>               <span class="bu">type</span><span class="op">=</span>DEFORMABLE_BODY)</span>
<span id="cb3-3"><a href="#cb3-3"></a>rpt.ReferencePoint(point<span class="op">=</span>(<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>))</span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a>rpt.Set(name<span class="op">=</span><span class="st">&#39;Set-1&#39;</span>, referencePoints<span class="op">=</span>rpt.referencePoints.values())</span></code></pre></div></li>
<li><p>Now import the nuts, washers and bolts by importing the file <a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/scripts/c_nutwasherbolt_516.py">https://github.com/Nidish96/Abaqus4Joints/blob/main/scripts/c_nutwasherbolt_516.py</a>.
You should be able to see the nut, washer and bolt, along with the half
beam and reference point created before, as follows after importing:
<img src="./figs/nwb.png" /> The Python script also assigns the material
"STEEL" (see above) to the parts.</p></li>
</ol>
<p>The file <a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/assets/assembly/model_step0.cae">model<sub>step0</sub>.cae</a>
stores the CAE file at the end of the above steps (building parts, and
partitioning).</p>
<h2 id="creating-appropriate-surface-sets">Creating appropriate surface
sets <span class="tag" data-tag-name="GUI"><span
class="smallcaps">GUI</span></span></h2>
<p>It is necessary to choose appropriate surface sets for the constraint
enforcement and, eventually, the interfacial mesh extraction. Doing this
with surfaces (before meshing) is advantageous since the same scripts
can be reused even if the model is remeshed.</p>
<ol>
<li>First select the <strong>interfacial faces</strong> on the half beam
model and assign the name <code class="verbatim">INSURF</code> to it.
You can do this through <code
class="verbatim">Tools-&gt;Surface-&gt;Create</code> and then selecting
the appropriate faces through the GUI. Select the faces by holding <code
class="verbatim">Shift</code> and deselect by holding <code
class="verbatim">Ctrl</code>. Here is a picture of the surface
highlighted in the viewport. <img src="./figs/insurf.png" /></li>
<li>Turn to the <em>outside</em> of the beam and select the faces around
the bolts individually and name them <code class="verbatim">BmW1</code>,
<code class="verbatim">BmW2</code>, and <code
class="verbatim">BmW3</code> respectively. These will be tied to the
washer for the analysis. (<code class="verbatim">BmWi</code> denotes the
i<sup>th</sup> Beam-Washer contact). Here is a picture of the relevant
surfaces highlighted (using different colors for each). <img
src="./figs/bmwsurfs.png" /></li>
<li>Create two surfaces on the <code class="verbatim">BOLT</code> model
as shown in the figure below. Name the surface marked white as <code
class="verbatim">BlW</code> and the surface marked green as <code
class="verbatim">BN</code>. (<code class="verbatim">BlW</code> denotes
the Bolt-Washer contact surface; <code class="verbatim">BN</code>
denotes the Bolt-Nut contact surface) <img
src="./figs/boltsurfs.png" /></li>
<li>Create two surfaces on the <code class="verbatim">NUT</code> model
as shown in the figure below. Name the white surface as <code
class="verbatim">NW</code> and the green surface as <code
class="verbatim">NB</code>. (<code class="verbatim">NW</code> denotes
the Nut-Washer contact surface; <code class="verbatim">NB</code> denotes
the Nut-Bolt contact surface) <strong>Note the direction axes
carefully.</strong> <img src="./figs/nutsurfs.png" /></li>
<li>Create two surface on the <code class="verbatim">WASHER</code> model
and label them as <code class="verbatim">WSTOP</code> and <code
class="verbatim">WSBOT</code> (short for Washer-Surface Top and Bottom).
Here is a graphical depiction of the model with the surfaces. <img
src="./figs/wshrsurf.png" /></li>
</ol>
<p>Now all the parts have been created and relevant surfaces have been
identified. <strong>Note</strong>: It is important to have traceable but
short names so that a lot of the repetitive tasks can be sped up
considerably using scripting.</p>
<h2 id="create-assembly">Create Assembly <span class="tag"
data-tag-name="GUI"><span class="smallcaps">GUI</span></span></h2>
<p><strong>Note</strong>: While importing the parts, choose Instance
Type as "Independent (Mesh on Instance)". This will be advantageous if
we want to modify the meshes just at the interface for mirror symmetry.
We will do independent meshing since it is good practice, although
independent meshes are not a requirement for this example (dependent
meshes can be used due to symmetry).</p>
<ol>
<li>Import the two beams and re-orient/move them as follows.
<strong>Note that the bolt-axis has to be pointed in the +z
direction.</strong> This will be the convention followed throughout this
tutorial. The green beam in the following is renamed as <code
class="verbatim">TOPBEAM</code> and the white beam in the following is
renamed as <code class="verbatim">BOTBEAM</code>. <img
src="./figs/asb1.png" /></li>
<li>Import one instance each of the <code class="verbatim">BOLT</code>
and <code class="verbatim">NUT</code> and 2 instances of the <code
class="verbatim">WASHER</code> and assemble them as shown. Ensure that
the washer is oriented (on each side) with the <code
class="verbatim">WSTOP</code> oriented in the <code>-z</code> direction
and the <code class="verbatim">WSBOT</code> is oriented in the
<code>+z</code> direction. Rename the washer instances in the top and
bottom as <code class="verbatim">TOPWASHER-1</code> and <code
class="verbatim">BOTWASHER-1</code> respectively. Rename the bolt and
nut as <code class="verbatim">NUT-1</code> and <code
class="verbatim">BOLT-1</code> respectively. <img
src="./figs/asbwn.png" /></li>
<li>Import one instance of the reference point <code
class="verbatim">REFPT</code>. As mentioned before, this will be used to
enforce bolt prestress. This will be achieved by first placing it at the
centroid of the intersection of the <code class="verbatim">BOLT</code>
and <code class="verbatim">NUT</code> (surfaces <code
class="verbatim">BN</code> and <code class="verbatim">NB</code>). It is
important that the reference point is placed at the centroid. This can
be done in the GUI by first moving it to an external point and then
translating it along the axis. The figure below shows an example (a
datum point was used for this here). Rename this to <code
class="verbatim">BPT-1</code> (standing for Bolt Point 1). <img
src="./figs/asrpt.png" /></li>
<li>Now import another instance of the reference point <code
class="verbatim">REFPT</code> and translate it to be coincident with
<code class="verbatim">BPT-1</code>. Rename this <code
class="verbatim">NPT-1</code> (standing for Nut Point 1). These two
points will have to be on the same geometrical point but equal and
opposite forces will be applied for the force application (see <a
href="#sec:boltprel">2.2</a> below for those steps). The point <code
class="verbatim">BPT-1</code> will be coupled to the bolt surface <code
class="verbatim">BN</code> and <code class="verbatim">NPT-1</code> will
be tied to the nut surface <code class="verbatim">NB</code> through RBE3
elements.</li>
<li>Use the "Linear Pattern" dialog and copy the bolt-washer-washer-nut
assembly thrice along the beam such that the assembly is complete. The
figure below shows the final assembly along with a representation of the
names of the different parts. Recall that the beam shown in the figure
below is <code class="verbatim">TOPBEAM</code> and the hidden one is
<code class="verbatim">BOTBEAM</code>. <img
src="./figs/as3bwn.png" /></li>
</ol>
<p>Now that the assembly is complete, the relevant constraints will have
to be enforced, followed by a realization of the bolt preload.</p>
<h1 id="constraints">Constraints</h1>
<h2 id="tie-constraint-enforcement">Tie-Constraint Enforcement <span
class="tag" data-tag-name="Script"><span
class="smallcaps">Script</span></span> <span class="tag"
data-tag-name="GUI"><span class="smallcaps">GUI</span></span></h2>
<p>All the following operations can be conducted in the
<code>Interaction</code> module in CAE. But since selecting each surface
can be a time-consuming process, we use the following for-loop in
ABAQUS-python (either call it as a script or just copy paste it into the
CLI) to make the required tie constraints. Specifically, it ties the
Bolt-Washer, Nut-Washer, and Washer-Beam surfaces. Note that in the last
set of constraints, we recall the fact that the bottom beam is flipped.
So <code class="verbatim">WASHER-1</code> is tied to <code
class="verbatim">BmW3</code> of the bottom beam (and so on for 2,3).</p>
<div class="sourceCode" id="cb4" data-startFrom=""><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>mdl <span class="op">=</span> mdb.models[<span class="st">&#39;Model-1&#39;</span>]</span>
<span id="cb4-2"><a href="#cb4-2"></a>ras <span class="op">=</span> mdl.rootAssembly</span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">4</span>):</span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="co"># Bolt-Washer Constraints</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>    mdl.Tie(name<span class="op">=</span><span class="st">&#39;BW-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i),</span>
<span id="cb4-7"><a href="#cb4-7"></a>            main<span class="op">=</span>ras.instances[<span class="st">&#39;TOPWASHER-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i)].surfaces[<span class="st">&#39;WSTOP&#39;</span>],</span>
<span id="cb4-8"><a href="#cb4-8"></a>            secondary<span class="op">=</span>ras.instances[<span class="st">&#39;BOLT-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i)].surfaces[<span class="st">&#39;BlW&#39;</span>],</span>
<span id="cb4-9"><a href="#cb4-9"></a>            positionToleranceMethod<span class="op">=</span>COMPUTED, adjust<span class="op">=</span>ON,</span>
<span id="cb4-10"><a href="#cb4-10"></a>            tieRotations<span class="op">=</span>ON, thickness<span class="op">=</span>ON)</span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="co"># Nut-Washer Constraints</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>    mdl.Tie(name<span class="op">=</span><span class="st">&#39;NW-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i),</span>
<span id="cb4-14"><a href="#cb4-14"></a>            main<span class="op">=</span>ras.instances[<span class="st">&#39;BOTWASHER-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i)].surfaces[<span class="st">&#39;WSBOT&#39;</span>],</span>
<span id="cb4-15"><a href="#cb4-15"></a>            secondary<span class="op">=</span>ras.instances[<span class="st">&#39;NUT-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i)].surfaces[<span class="st">&#39;NW&#39;</span>],</span>
<span id="cb4-16"><a href="#cb4-16"></a>            positionToleranceMethod<span class="op">=</span>COMPUTED, adjust<span class="op">=</span>ON,</span>
<span id="cb4-17"><a href="#cb4-17"></a>            tieRotations<span class="op">=</span>ON, thickness<span class="op">=</span>ON)</span>
<span id="cb4-18"><a href="#cb4-18"></a></span>
<span id="cb4-19"><a href="#cb4-19"></a>    <span class="co"># TopWasher-Beam Constraints</span></span>
<span id="cb4-20"><a href="#cb4-20"></a>    mdl.Tie(name<span class="op">=</span><span class="st">&#39;BmTW-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i),</span>
<span id="cb4-21"><a href="#cb4-21"></a>            main<span class="op">=</span>ras.instances[<span class="st">&#39;TOPBEAM&#39;</span>].surfaces[<span class="st">&#39;BmW</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i)],</span>
<span id="cb4-22"><a href="#cb4-22"></a>            secondary<span class="op">=</span>ras.instances[<span class="st">&#39;TOPWASHER-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i)].surfaces[<span class="st">&#39;WSBOT&#39;</span>],</span>
<span id="cb4-23"><a href="#cb4-23"></a>            positionToleranceMethod<span class="op">=</span>COMPUTED, adjust<span class="op">=</span>ON,</span>
<span id="cb4-24"><a href="#cb4-24"></a>            tieRotations<span class="op">=</span>ON, thickness<span class="op">=</span>ON)</span>
<span id="cb4-25"><a href="#cb4-25"></a></span>
<span id="cb4-26"><a href="#cb4-26"></a>    <span class="co"># BotWasher-Beam Constraints</span></span>
<span id="cb4-27"><a href="#cb4-27"></a>    mdl.Tie(name<span class="op">=</span><span class="st">&#39;BmBW-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i),</span>
<span id="cb4-28"><a href="#cb4-28"></a>            main<span class="op">=</span>ras.instances[<span class="st">&#39;BOTBEAM&#39;</span>].surfaces[<span class="st">&#39;BmW</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>((<span class="dv">3</span><span class="op">-</span>i)<span class="op">%</span><span class="dv">3</span><span class="op">+</span><span class="dv">1</span>)],</span>
<span id="cb4-29"><a href="#cb4-29"></a>            secondary<span class="op">=</span>ras.instances[<span class="st">&#39;BOTWASHER-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i)].surfaces[<span class="st">&#39;WSTOP&#39;</span>],</span>
<span id="cb4-30"><a href="#cb4-30"></a>            positionToleranceMethod<span class="op">=</span>COMPUTED, adjust<span class="op">=</span>ON,</span>
<span id="cb4-31"><a href="#cb4-31"></a>            tieRotations<span class="op">=</span>ON, thickness<span class="op">=</span>ON)</span></code></pre></div>
<h2 id="bolt-preload-realization">Bolt Preload Realization <span
class="tag" data-tag-name="Script"><span
class="smallcaps">Script</span></span> <span class="tag"
data-tag-name="GUI"><span class="smallcaps">GUI</span></span></h2>
<p><span id="sec:boltprel"></span> You might already have encountered
the different parts of the model above that were carefully constructed
for the bolt preload application (bolt-shank partitioning, reference
points, etc.). &lt;details class="code-details" style ="padding: 1em;
background-color: #cccccc; <em>* background-color: pink; *</em>
border-radius: 15px; color: hsl(157 75%); font-size: 0.9em; box-shadow:
0.05em 0.1em 5px 0.01em #00000057;"&gt; &lt;summary&gt; &lt;strong&gt;
&lt;font face="Courier" size="3" color="black"&gt; What 's wrong with
the inbuilt Bolt Pretension in ABAQUS? &lt;/font&gt; &lt;/strong&gt;
&lt;/summary&gt; <strong>The ABAQUS Approach</strong></p>
<ul>
<li>You can find the ABAQUS documentation for the bolt load <a
href="https://classes.engineering.wustl.edu/2009/spring/mase5513/abaqus/docs/v6.6/books/usi/default.htm?startat=pt04ch21s02s01.html">here</a>.</li>
<li>ABAQUS/CAE applies bolt load by specifying a <strong>bolt
cross-section</strong>, a <strong>bolt axis</strong>, and the
<strong>bolt load</strong>.</li>
<li>The documentation for the ABAQUS implementation can be found <a
href="https://classes.engineering.wustl.edu/2009/spring/mase5513/abaqus/docs/v6.6/books/usb/default.htm?startat=pt07ch27s05aus102.html#usb-prc-ppretension">here</a>.</li>
<li>The load is applied in the context of a constraint:
<ul>
<li>It can be a load constraint wherein the displacements/strains at the
cross-section are adjusted to match the load.</li>
<li>It can be a deformation constraint, wherein the loads are
adjusted.</li>
</ul></li>
<li>In either case, the bolt load <strong>can not be written down as a
constant load vector</strong> that can be exported/used elsewhere.</li>
<li>It is therefore not possible to use the inbuilt bolt pretension in a
substructured analysis, for example.</li>
<li>Here are the <a
href="https://classes.engineering.wustl.edu/2009/spring/mase5513/abaqus/docs/v6.6/books/usb/default.htm?startat=pt07ch27s05aus102.html#usb-prc-ppretension">documented
limitations</a>:
<ul>
<li>An assembly load cannot be specified within a substructure.</li>
<li>If a submodeling analysis is performed, any pre-tension section
should not cross regions where driven nodes are specified.</li>
<li>Nodes of a pre-tension section should not be connected to other
parts of the body through multi-point constraints.</li>
</ul></li>
</ul>
<p><strong>Our Approach</strong></p>
<ul>
<li>Our method of bolt pretension application addresses all the above
issues pertaining to substructuring/submodeling by using
<strong>Distributed Coupling</strong> elements (aka RBE3/Spider elements
in other FE software).</li>
<li>We will first couple the bolt-shank area that is in contact with the
nut (the thread area) to a 6DOF point (3 translations + 3 rotations),
and do the same for the nut inner surface, with another point, using
<strong>Distributed coupling</strong> elements.</li>
<li>The bolt and nut will be "fastened" by arresting every DOF in these
two nodes except the axial DOF. This will ensure that the only relative
displacement between the bolt and nut are axial, which may result from
tightening/loosening of the bolt.</li>
<li>A <strong>"pulling force" is applied on the bolt-coupling
node</strong>, which acts as the tension on the bolt, and a
<strong>"pushing force" is applied on the nut-coupling node</strong>,
which acts to maintain the system's equilibrium, i.e., fastening.</li>
<li>It is understood that there is an interface that the assembly is
tightening, which should provide the required reaction forces to balance
everything out.</li>
<li>Now, the bolt load is merely a constant force vector which can be
manipulated as one desires.</li>
</ul>
<p>&lt;/details&gt;</p>
<p>We will now go through the process of specifying this.</p>
<ol>
<li><p>First couple the bolt-shank surface <code
class="verbatim">BN</code> with the appropriate reference point (<code
class="verbatim">BPT-n</code>). This can be done in CAE through
<code>Interaction-&gt;Create Constraint-&gt;Tie</code>. The following is
python code that will do this in a loop.</p>
<div class="sourceCode" id="cb5" data-startFrom=""><pre
class="sourceCode numberSource python numberLines continuedSourceBlock"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># Bolt and Nut Point Coupling</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">4</span>):</span>
<span id="cb5-3"><a href="#cb5-3"></a>    mdl.Coupling(name<span class="op">=</span><span class="st">&#39;BPC-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i),</span>
<span id="cb5-4"><a href="#cb5-4"></a>                 controlPoint<span class="op">=</span>ras.instances[<span class="st">&#39;BPT-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i)].sets[<span class="st">&#39;Set-1&#39;</span>],</span>
<span id="cb5-5"><a href="#cb5-5"></a>                 surface<span class="op">=</span>ras.instances[<span class="st">&#39;BOLT-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i)].surfaces[<span class="st">&#39;BN&#39;</span>],</span>
<span id="cb5-6"><a href="#cb5-6"></a>                 influenceRadius<span class="op">=</span>WHOLE_SURFACE, couplingType<span class="op">=</span>STRUCTURAL,</span>
<span id="cb5-7"><a href="#cb5-7"></a>                 weightingMethod<span class="op">=</span>UNIFORM)</span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a>    mdl.Coupling(name<span class="op">=</span><span class="st">&#39;NPC-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i),</span>
<span id="cb5-10"><a href="#cb5-10"></a>                 controlPoint<span class="op">=</span>ras.instances[<span class="st">&#39;NPT-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i)].sets[<span class="st">&#39;Set-1&#39;</span>],</span>
<span id="cb5-11"><a href="#cb5-11"></a>                 surface<span class="op">=</span>ras.instances[<span class="st">&#39;NUT-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i)].surfaces[<span class="st">&#39;NB&#39;</span>],</span>
<span id="cb5-12"><a href="#cb5-12"></a>                 influenceRadius<span class="op">=</span>WHOLE_SURFACE, couplingType<span class="op">=</span>STRUCTURAL,</span>
<span id="cb5-13"><a href="#cb5-13"></a>                 weightingMethod<span class="op">=</span>UNIFORM)</span></code></pre></div></li>
<li><p>Now we constrain the X, Y, Rx, Ry, and Rz DOFs (all 5 DOFs other
than the Z DOF, which is the bolt-axis) using equation constraints. If
the bolt axis is not a principal direction in the model, then the
constraint equations must be modified appropriately. Note that this can
also be used in the large deformation context through the use of a local
coordinate system (the global CS is used here, so <strong>applicability
is restricted to small deformations</strong>). This can be done in CAE
through <code>Interaction-&gt;Create Constraint-&gt;Coupling</code>. The
following code does this through a nested loop such that <strong><code
class="verbatim">BNEQn-m</code> represents the m<sup>th</sup> DOF
constraint at the n<sup>th</sup> location</strong>.</p>
<div class="sourceCode" id="cb6" data-startFrom=""><pre
class="sourceCode numberSource python numberLines continuedSourceBlock"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="co"># Equation Constraints constraining bolt and nut ref-points to each other</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">4</span>):</span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="cf">for</span> j <span class="kw">in</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]:</span>
<span id="cb6-4"><a href="#cb6-4"></a>        mdl.Equation(name<span class="op">=</span><span class="st">&#39;BNEQ</span><span class="sc">%d</span><span class="st">-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i, j),</span>
<span id="cb6-5"><a href="#cb6-5"></a>                     terms<span class="op">=</span>((<span class="fl">1.0</span>, <span class="st">&#39;BPT-</span><span class="sc">%d</span><span class="st">.Set-1&#39;</span> <span class="op">%</span>(i), j),</span>
<span id="cb6-6"><a href="#cb6-6"></a>                            (<span class="op">-</span><span class="fl">1.0</span>,<span class="st">&#39;NPT-</span><span class="sc">%d</span><span class="st">.Set-1&#39;</span> <span class="op">%</span>(i), j)))</span></code></pre></div>
<p>Here is an image showing the constraints applied graphically. <img
src="./figs/conss.png" /></p></li>
<li><p>We next create a static analysis step
(<code>Step-&gt;Create Step-&gt;Static, General</code>) named as <code
class="verbatim">PRESTRESS</code>. This can be done in CAE, but here is
the Python code.</p>
<div class="sourceCode" id="cb7" data-startFrom=""><pre
class="sourceCode numberSource python numberLines continuedSourceBlock"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>mdl.StaticStep(name<span class="op">=</span><span class="st">&#39;PRESTRESS&#39;</span>, previous<span class="op">=</span><span class="st">&#39;Initial&#39;</span>, nlgeom<span class="op">=</span>ON)</span></code></pre></div>
<p><strong>Note</strong>: Nonlinear Geometric effects (nlgeom) is set to
ON since this was found to be helpful for convergence of prestress
analysis.</p></li>
<li><p>We finally apply bolt forces as concentrated forces at the <code
class="verbatim">BPT-n</code> and <code class="verbatim">NPT-n</code>
reference points. Switch to the <code class="verbatim">Load</code>
module to do this from CAE. The following python code applies a
tightening load of 12kN to each bolt.</p>
<div class="sourceCode" id="cb8" data-startFrom=""><pre
class="sourceCode numberSource python numberLines continuedSourceBlock"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="co"># Apply forces</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>bpmag <span class="op">=</span> <span class="fl">12e3</span>  <span class="co"># 12kN bolt-load</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">4</span>):</span>
<span id="cb8-4"><a href="#cb8-4"></a>    <span class="co"># Force in +z on bolt-points</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    mdl.ConcentratedForce(name<span class="op">=</span><span class="st">&#39;BoltLoad-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i), createStepName<span class="op">=</span><span class="st">&#39;PRESTRESS&#39;</span>,</span>
<span id="cb8-6"><a href="#cb8-6"></a>                          region<span class="op">=</span>ras.instances[<span class="st">&#39;BPT-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i)].sets[<span class="st">&#39;Set-1&#39;</span>],</span>
<span id="cb8-7"><a href="#cb8-7"></a>                          cf3<span class="op">=</span>bpmag, distributionType<span class="op">=</span>UNIFORM)</span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a>    <span class="co"># Force in -z on bolt-points</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>    mdl.ConcentratedForce(name<span class="op">=</span><span class="st">&#39;NutLoad-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i), createStepName<span class="op">=</span><span class="st">&#39;PRESTRESS&#39;</span>,</span>
<span id="cb8-11"><a href="#cb8-11"></a>                          region<span class="op">=</span>ras.instances[<span class="st">&#39;NPT-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i)].sets[<span class="st">&#39;Set-1&#39;</span>],</span>
<span id="cb8-12"><a href="#cb8-12"></a>                          cf3<span class="op">=-</span>bpmag, distributionType<span class="op">=</span>UNIFORM)</span></code></pre></div>
<p><img src="./figs/loads.png" /></p></li>
<li><p><strong>Note</strong> that the bolt load constructed in the above
manner is a "linear" load - i.e., the load can be increased/decreased by
scaling the resulting force vector. It is assumed here that all 3 bolts
are loaded equally. If this is not the case, the different loads can be
exported separately and scaled appropriately (for external analysis). It
is, however, a physical requirement for equilibrium that <code
class="verbatim">BoltLoad-n</code> and <code
class="verbatim">NutLoad-n</code> have to be of equal magnitude and
opposite signs.</p></li>
</ol>
<p>The file <a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/assets/assembly/model_step1.cae">model<sub>step1</sub>.cae</a>
stores the CAE-file generated after the end of the above steps. We will
now proceed with meshing.</p>
<h1 id="meshing">Meshing</h1>
<p>Since the model is perfectly symmetric, it is sufficient to mesh the
model with a global seed, after seeding the interface area locally.
Switch to the <code class="verbatim">Mesh</code> module for this
section.</p>
<p>If such symmetry is not available, one may choose a more direct
approach by using the <code>bottom-up</code> meshing to copy the mesh
from one interface to another directly. Please <a
href="mailto:nidish.balaji@ila.uni-stuttgart.de">write to me</a> if
you'd like an example for this.</p>
<h2 id="meshing-instructions">Meshing Instructions <span class="tag"
data-tag-name="GUI"><span class="smallcaps">GUI</span></span></h2>
<ol>
<li>Choose <code>Mesh-&gt;Assign Mesh Controls</code> and select the
whole assembly (all the instances). We will use a structured
hex-dominated element type for the full model (it will give a warning
that this is not possible for certain regions. This is okay). <img
src="./figs/globmesh.png" /></li>
<li>Now choose <code>Mesh-&gt;Seed Part Instance</code> and select all
the instances again. Set 0.00254 as the global mesh seed (to ensure 10
elements across thickness) and 0.05 for curvature control. <img
src="./figs/gmeshseed.png" /></li>
<li>Apply local seeds at the interface as shown here (on both
interfaces). Use the <code>Mesh-&gt;Seed Edges</code> tool by choosing
the Method as "By Number" and specify the number of elements. <img
src="./figs/lmeshseeds.png" /></li>
<li>Now mesh the assembly using <code>Mesh-&gt;Mesh Part Instance</code>
and selecting all the part instances. Here is a view of the interfacial
mesh you should get after the above seeding. <img
src="./figs/mesh.png" /></li>
<li>Here is an image of the total assembly with the mesh. <img
src="./figs/fullmesh.png" /></li>
</ol>
<p>The file <a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/assets/assembly/model_step1.cae">model<sub>step1</sub>.cae</a>
stores the CAE-file along with the mesh.</p>
<h2
id="optional-recommended-verify-correctness-of-model-through-frictionless-prestress">(Optional,
recommended) Verify correctness of model through frictionless prestress
<span class="tag" data-tag-name="GUI"><span
class="smallcaps">GUI</span></span></h2>
<p>We will now conduct a simple frictionless contact analysis to verify
the correctness of the model.</p>
<p><strong>Setup</strong></p>
<ol>
<li>For the static prestress analysis, first a surface-to-surface
contact interaction property has to be created and assigned. You can do
this from CAE starting from
<code>Interaction-&gt;Create Interaction</code> and following the steps
in the figure below. <img src="./figs/setcontact.png" /></li>
<li>Now create two linear frequency steps, one before and one after the
static prestress step, as shown in the figure below. Request 30
eigenvalues in each case. <img src="./figs/lfreq.png" /></li>
<li>Create 2 jobs. Suppress the interaction property in the first one
and have just <code>FREQ1</code> active (see figure below). <img
src="./figs/run1.png" /> For the second job, suppress <code>FREQ1</code>
and resume the other steps. Resume the surface interaction properties
(see figure below). <img src="./figs/run2.png" /> Optionally, field
outputs for <code>FREQ2</code> (by default it will be set to none if
<code>FREQ1</code> is suppressed). You can do this in
<code>Step-&gt;Create Field Outputs</code>. <img
src="./figs/run2_fo.png" /></li>
</ol>
<p><strong>Results</strong></p>
<ol>
<li><p>The first analysis should reveal that the system has <strong>7
Rigid Body Modes</strong> (RBMs). This is because the two beams are
constrained together in all directions except the axial (where
tightening has to happen). So the number of RBMs has to be <span
class="math inline">2 × 6 − 5 = 7</span>. The first 10 modal frequencies
have to be (frequencies in cycles/time, or Hz):</p>
<table>
<thead>
<tr class="header">
<th>Index</th>
<th>Frequency</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1.0515e-3</td>
</tr>
<tr class="even">
<td>2</td>
<td>1.2851e-3</td>
</tr>
<tr class="odd">
<td>3</td>
<td>1.4602e-3</td>
</tr>
<tr class="even">
<td>4</td>
<td>1.6246e-3</td>
</tr>
<tr class="odd">
<td>5</td>
<td>1.6592e-3</td>
</tr>
<tr class="even">
<td>6</td>
<td>1.8082e-3</td>
</tr>
<tr class="odd">
<td>7</td>
<td>1.9025e-3</td>
</tr>
<tr class="even">
<td>8</td>
<td>70.323</td>
</tr>
<tr class="odd">
<td>9</td>
<td>151.26</td>
</tr>
<tr class="even">
<td>10</td>
<td>609.25</td>
</tr>
</tbody>
</table>
<p>In the above, modes 1-7 are RBMs and modes 8 onwards are the elastic
modes. Looking at the mode-shapes should make it clear that the two
beams are free to move axially (the following is mode 1, for eg). <img
src="./figs/res1.png" /></p></li>
<li><p>The second analysis should converge within a few iterations. If
not, the "Initial Increment Size" in
<code>Step-&gt;PRESTRESS-&gt;Edit-&gt;Increment-&gt;Initial Increment Size</code>
has to be reduced. If it doesn't converge, try to apply a boundary
condition to make the problem well-posed, and try again. If it still
doesn't converge, check your model again. Here is a picture of the
contact pressures at the interface at the end of the static prestress
step. <img src="./figs/res2_1.png" /></p></li>
<li><p>By default, ABAQUS <strong>fuses the nodes</strong> that are in
contact at the end of the hard contact step, for the eigenvalue analysis
that follows it (Linear Perturbation step). Since we are using
frictionless tangential here, the tangential DOFs are not fused. Here
are the first 10 frequencies from the <code
class="verbatim">FREQ2</code> step (frequencies in cycles/time, or
Hz):</p>
<table>
<thead>
<tr class="header">
<th>Index</th>
<th>Frequency</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0.00</td>
</tr>
<tr class="even">
<td>2</td>
<td>0.00</td>
</tr>
<tr class="odd">
<td>3</td>
<td>0.00</td>
</tr>
<tr class="even">
<td>4</td>
<td>0.00</td>
</tr>
<tr class="odd">
<td>5</td>
<td>0.00</td>
</tr>
<tr class="even">
<td>6</td>
<td>2.2068e-3</td>
</tr>
<tr class="odd">
<td>7</td>
<td>141.10</td>
</tr>
<tr class="even">
<td>8</td>
<td>152.42</td>
</tr>
<tr class="odd">
<td>9</td>
<td>570.33</td>
</tr>
<tr class="even">
<td>10</td>
<td>643.49</td>
</tr>
</tbody>
</table>
<p>It must be observed that the model, under the prestressed state,
<strong>has only 6 RBMs</strong>. In other words, the bolt-axial
direction has now been fixed due to the fact that the contact
constraints are active on at least one spot on the interface.</p></li>
<li><p>If your model passes all the above, then you are ready to
proceed.</p></li>
<li><p><strong>Note, however, that this does not imply accuracy of the
model. One would have to do a mesh convergence analysis in this
case.</strong> For contact problems, it is well known that the
interfacial discretization must be very fine for convergence. Much
coarser meshes are, however, found to be sufficient for predicting
global quantities such as natural frequency and (nonlinear) damping
estimates, etc. Such a convergence analysis is presented in the appendix
of <a href="https://scholarship.rice.edu/handle/1911/113700">this
thesis</a>.</p></li>
</ol>
<p>The file <a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/assets/assembly/model_step2.cae">model<sub>step2</sub>.cae</a>
is the cae file containing the model with the above tests included.</p>
<h1 id="postprocess">Postprocess</h1>
<p>Now that the model is verified to be correct/consistent, we will
proceed with the steps necessary for substructured Matrix
Extraction.</p>
<p>Before proceeding it is necessary to first identify nodes on the
meshed model that correspond to the input and output locations. Choose
the mid point on the right end as the output node for this tutorial.
Create a node set called <code class="verbatim">OutNodes</code> by
selecting <code>Mesh-&gt;Tools-&gt;Set-&gt;Create-&gt;Node</code> and
choosing the node. Select "unsorted node set" if available.</p>
<p><img src="./figs/outnode.png" /> It is possible to choose multiple
nodes here if you have a MIMO case.</p>
<p>It is also helpful to use global node and element indexing
henceforth. This can be specified in
<code>Model-&gt;Edit Attributes-&gt;Model-1</code> as follows:</p>
<p><img src="./figs/modl.png" width="300" /></p>
<h2
id="reorganize-interfacial-node-sets-readjust-if-necessary">Reorganize
Interfacial Node Sets (readjust if necessary) <span class="tag"
data-tag-name="Script"><span class="smallcaps">Script</span></span></h2>
<p>Although we have taken care to ensure that the mesh of the <code
class="verbatim">TOPBEAM</code> and <code
class="verbatim">BOTBEAM</code> are conformal at the interface, minor
imperfections in the nodal locations may exist. Furthermore, the
ordering of the nodes on the top interface will be different from that
on the bottom interface. Through some scripting, we can create node sets
in such a way that the top and bottom interface nodesets are ordered in
a convenient fashion.</p>
<p>You can use the <a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/assets/assembly/model_step1a.cae">model<sub>step1a</sub>.cae</a>
and work along if you are here just for this section.</p>
<ol>
<li><p>We use the following slightly modified header for this
script:</p>
<div class="sourceCode" id="cb9" data-startFrom=""><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># -*- coding: utf-8 -*-</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co"># 1. Preamble</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="im">import</span> sys</span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb9-5"><a href="#cb9-5"></a></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="im">from</span> part <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="im">from</span> material <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="im">from</span> section <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="im">from</span> assembly <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="im">from</span> step <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="im">from</span> interaction <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="im">from</span> load <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="im">from</span> mesh <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="im">from</span> optimization <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-15"><a href="#cb9-15"></a><span class="im">from</span> job <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="im">from</span> sketch <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-17"><a href="#cb9-17"></a><span class="im">from</span> visualization <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-18"><a href="#cb9-18"></a><span class="im">from</span> connectorBehavior <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-19"><a href="#cb9-19"></a></span>
<span id="cb9-20"><a href="#cb9-20"></a><span class="im">from</span> abaqus <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-21"><a href="#cb9-21"></a><span class="im">from</span> abaqusConstants <span class="im">import</span> <span class="op">*</span></span>
<span id="cb9-22"><a href="#cb9-22"></a><span class="im">from</span> caeModules <span class="im">import</span> <span class="op">*</span> </span>
<span id="cb9-23"><a href="#cb9-23"></a><span class="im">import</span> regionToolset</span>
<span id="cb9-24"><a href="#cb9-24"></a><span class="im">import</span> job</span>
<span id="cb9-25"><a href="#cb9-25"></a><span class="im">import</span> step</span>
<span id="cb9-26"><a href="#cb9-26"></a><span class="im">import</span> sets</span>
<span id="cb9-27"><a href="#cb9-27"></a></span>
<span id="cb9-28"><a href="#cb9-28"></a>mdl <span class="op">=</span> mdb.models[<span class="st">&#39;Model-1&#39;</span>]</span>
<span id="cb9-29"><a href="#cb9-29"></a>ras <span class="op">=</span> mdl.rootAssembly</span>
<span id="cb9-30"><a href="#cb9-30"></a></span>
<span id="cb9-31"><a href="#cb9-31"></a>mdl.setValues(noPartsInputFile<span class="op">=</span>ON)</span></code></pre></div></li>
<li><p>Now we identify the top and bottom surface nodes, and store the
top nodes and elements into separate variables. The node and element
ordering of the top nodes will be preserved, and the nodes in the bottom
will be resorted according to this in #3 below.</p>
<div class="sourceCode" id="cb10" data-startFrom=""><pre
class="sourceCode numberSource python numberLines continuedSourceBlock"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># 2. Get top and bottom surfaces and nodes</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>topsurf <span class="op">=</span> ras.instances[<span class="st">&#39;TOPBEAM&#39;</span>].surfaces[<span class="st">&#39;INSURF&#39;</span>]</span>
<span id="cb10-3"><a href="#cb10-3"></a>botsurf <span class="op">=</span> ras.instances[<span class="st">&#39;BOTBEAM&#39;</span>].surfaces[<span class="st">&#39;INSURF&#39;</span>]</span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a>topnodes <span class="op">=</span> topsurf.nodes</span>
<span id="cb10-6"><a href="#cb10-6"></a>botnodes <span class="op">=</span> botsurf.nodes</span>
<span id="cb10-7"><a href="#cb10-7"></a>N <span class="op">=</span> <span class="bu">len</span>(topnodes)  <span class="co"># Number of nodes</span></span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="co"># Top Nodes and Coordinates</span></span>
<span id="cb10-10"><a href="#cb10-10"></a>Topnd_dict <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>([topnodes[i].label</span>
<span id="cb10-11"><a href="#cb10-11"></a>                       <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N)], <span class="bu">range</span>(N)))</span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="co"># maps original node ID (in FE model) to</span></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="co"># node ID in interface node set</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>TopNdCds <span class="op">=</span> np.array([topnodes[i].coordinates</span>
<span id="cb10-15"><a href="#cb10-15"></a>                     <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N)])</span>
<span id="cb10-16"><a href="#cb10-16"></a></span>
<span id="cb10-17"><a href="#cb10-17"></a><span class="co"># Top Elements</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>TopEls <span class="op">=</span> np.array([topsurf.elements[i].connectivity</span>
<span id="cb10-19"><a href="#cb10-19"></a>                   <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(topsurf.elements))])</span>
<span id="cb10-20"><a href="#cb10-20"></a>ELS <span class="op">=</span> np.zeros((TopEls.shape[<span class="dv">0</span>], <span class="dv">5</span>), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb10-21"><a href="#cb10-21"></a><span class="cf">for</span> ne <span class="kw">in</span> <span class="bu">range</span>(TopEls.shape[<span class="dv">0</span>]):</span>
<span id="cb10-22"><a href="#cb10-22"></a>    elefac <span class="op">=</span> topsurf.elements[ne].getElemFaces()</span>
<span id="cb10-23"><a href="#cb10-23"></a></span>
<span id="cb10-24"><a href="#cb10-24"></a>    <span class="co"># Gives you the list of faces on the interface</span></span>
<span id="cb10-25"><a href="#cb10-25"></a>    <span class="co"># (we only expect a single face here)</span></span>
<span id="cb10-26"><a href="#cb10-26"></a>    fe <span class="op">=</span> np.argwhere([<span class="bu">all</span>([Topnd_dict.has_key(x) <span class="cf">for</span> x <span class="kw">in</span> </span>
<span id="cb10-27"><a href="#cb10-27"></a>                           [elefac[k].getNodes()[i].label</span>
<span id="cb10-28"><a href="#cb10-28"></a>                            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>)]])</span>
<span id="cb10-29"><a href="#cb10-29"></a>                      <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">6</span>)])[<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb10-30"><a href="#cb10-30"></a>    ELS[ne, <span class="dv">0</span>] <span class="op">=</span> ne</span>
<span id="cb10-31"><a href="#cb10-31"></a>    <span class="co"># Searches for the face where all the nodes are in the interface</span></span>
<span id="cb10-32"><a href="#cb10-32"></a>    <span class="co"># and returns those nodes</span></span>
<span id="cb10-33"><a href="#cb10-33"></a>    ELS[ne, <span class="dv">1</span>:] <span class="op">=</span> [Topnd_dict[x] <span class="cf">for</span> x <span class="kw">in</span></span>
<span id="cb10-34"><a href="#cb10-34"></a>                   [elefac[fe].getNodes()[k].label</span>
<span id="cb10-35"><a href="#cb10-35"></a>                    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>)]]</span>
<span id="cb10-36"><a href="#cb10-36"></a>    ELS[ne, :] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb10-37"><a href="#cb10-37"></a></span>
<span id="cb10-38"><a href="#cb10-38"></a><span class="co"># Save interfacial nodes and elements to txt files</span></span>
<span id="cb10-39"><a href="#cb10-39"></a>np.savetxt(<span class="st">&#39;Nodes.dat&#39;</span>, TopNdCds) <span class="co"># Save to dat file</span></span>
<span id="cb10-40"><a href="#cb10-40"></a>np.savetxt(<span class="st">&#39;Elements.dat&#39;</span>, ELS, fmt<span class="op">=</span><span class="st">&#39;</span><span class="sc">%d</span><span class="st">&#39;</span>)</span></code></pre></div></li>
<li><p>Now we extract the bottom nodes and sort them.</p>
<div class="sourceCode" id="cb11" data-startFrom=""><pre
class="sourceCode numberSource python numberLines continuedSourceBlock"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># 3. Node Pairing. We assume len(botnodes)=len(topnodes).</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>botleft <span class="op">=</span> <span class="bu">range</span>(N)</span>
<span id="cb11-3"><a href="#cb11-3"></a>bts <span class="op">=</span> []</span>
<span id="cb11-4"><a href="#cb11-4"></a>tmi <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb11-6"><a href="#cb11-6"></a>    <span class="co"># Calculates deviation of selected node coordinate on bottom to each</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="co"># node coordinate on top and &quot;assigns&quot; the closest one to the index.</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>    devns <span class="op">=</span> topnodes[i].coordinates <span class="op">-</span> np.array([botnodes[j].coordinates</span>
<span id="cb11-9"><a href="#cb11-9"></a>                                                <span class="cf">for</span> j <span class="kw">in</span> botleft])</span>
<span id="cb11-10"><a href="#cb11-10"></a>    bts.append(</span>
<span id="cb11-11"><a href="#cb11-11"></a>        botleft.pop(</span>
<span id="cb11-12"><a href="#cb11-12"></a>            np.argmin(</span>
<span id="cb11-13"><a href="#cb11-13"></a>                np.linalg.norm(</span>
<span id="cb11-14"><a href="#cb11-14"></a>                    devns, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb11-15"><a href="#cb11-15"></a>            )</span>
<span id="cb11-16"><a href="#cb11-16"></a>        )</span>
<span id="cb11-17"><a href="#cb11-17"></a>    )</span></code></pre></div></li>
<li><p>We now adjust the nodes on the bottom (this affects the FE mesh
directly!)</p>
<div class="sourceCode" id="cb12" data-startFrom=""><pre
class="sourceCode numberSource python numberLines continuedSourceBlock"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="co"># 4. Adjust Nodes on Bottom Beam Interface to Match Top Beam Exactly</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb12-3"><a href="#cb12-3"></a>    ras.editNode(nodes<span class="op">=</span>botnodes[bts[i]:bts[i]<span class="op">+</span><span class="dv">1</span>],</span>
<span id="cb12-4"><a href="#cb12-4"></a>                 coordinates<span class="op">=</span>(topnodes[i].coordinates,))</span></code></pre></div></li>
<li><p>We now create nodesets for the top (<code
class="verbatim">TOPS_NDS</code>) and bottom (<code
class="verbatim">BOTS_NDS</code>).</p>
<div class="sourceCode" id="cb13" data-startFrom=""><pre
class="sourceCode numberSource python numberLines continuedSourceBlock"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="co"># 5. Create Node Sets</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>botpairednds <span class="op">=</span> botnodes.sequenceFromLabels(<span class="bu">tuple</span>([botnodes[i].label</span>
<span id="cb13-3"><a href="#cb13-3"></a>                                                  <span class="cf">for</span> i <span class="kw">in</span> bts]))</span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="co"># Reordering from the sorting above</span></span>
<span id="cb13-5"><a href="#cb13-5"></a></span>
<span id="cb13-6"><a href="#cb13-6"></a>ras.SetFromNodeLabels(name<span class="op">=</span><span class="st">&quot;TOPS_NDS&quot;</span>, </span>
<span id="cb13-7"><a href="#cb13-7"></a>                      nodeLabels<span class="op">=</span>((topnodes[<span class="dv">0</span>].instanceName, </span>
<span id="cb13-8"><a href="#cb13-8"></a>                                   <span class="bu">tuple</span>([topnodes[i].label</span>
<span id="cb13-9"><a href="#cb13-9"></a>                                          <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N)])),),</span>
<span id="cb13-10"><a href="#cb13-10"></a>                      unsorted<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb13-11"><a href="#cb13-11"></a>ras.SetFromNodeLabels(name<span class="op">=</span><span class="st">&quot;BOTS_NDS&quot;</span>, </span>
<span id="cb13-12"><a href="#cb13-12"></a>                      nodeLabels<span class="op">=</span>((botpairednds[<span class="dv">0</span>].instanceName, </span>
<span id="cb13-13"><a href="#cb13-13"></a>                                   [botpairednds[i].label</span>
<span id="cb13-14"><a href="#cb13-14"></a>                                    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(botpairednds))]),),</span>
<span id="cb13-15"><a href="#cb13-15"></a>                      unsorted<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<p>Note that we've used the unsorted keyword to ensure that ABAQUS does
not reorder the nodesets (default behavior).</p></li>
<li><p>We now simplify the model by removing all interaction properties
and steps (except initial). One side-effect of doing this is that this
removes the bolt loads also, since loads can only be saved when there is
a corresponding step! So we will reintroduce the bolt loads in the
substructuring step in #8 below.</p>
<div class="sourceCode" id="cb14" data-startFrom=""><pre
class="sourceCode numberSource python numberLines continuedSourceBlock"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="co"># 6. Simplify model (remove interactions, all steps, etc.)</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>tmp <span class="op">=</span> mdl.interactions</span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="cf">while</span> <span class="bu">len</span>(tmp) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="kw">del</span> tmp[tmp.keys()[<span class="op">-</span><span class="dv">1</span>]]</span>
<span id="cb14-5"><a href="#cb14-5"></a></span>
<span id="cb14-6"><a href="#cb14-6"></a>tmp <span class="op">=</span> mdl.interactionProperties</span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="cf">while</span> <span class="bu">len</span>(tmp) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb14-8"><a href="#cb14-8"></a>    <span class="kw">del</span> tmp[tmp.keys()[<span class="op">-</span><span class="dv">1</span>]]</span>
<span id="cb14-9"><a href="#cb14-9"></a></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="co"># Remove all steps except initial</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>tmp <span class="op">=</span> mdl.steps</span>
<span id="cb14-12"><a href="#cb14-12"></a><span class="cf">while</span> <span class="bu">len</span>(tmp) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb14-13"><a href="#cb14-13"></a>    <span class="kw">del</span> tmp[tmp.keys()[<span class="op">-</span><span class="dv">1</span>]]</span></code></pre></div></li>
</ol>
<h2
id="setup-fixed-interface-cms-hcb-cms-with-linear-frequency-and-substructure-steps">Setup
Fixed interface CMS (HCB-CMS) with linear frequency and substructure
steps <span class="tag" data-tag-name="Script"><span
class="smallcaps">Script</span></span></h2>
<ol>
<li><p>We are interested in <strong>Fixed-Interface Component Mode
Synthesis</strong> with 20 retained modes. So we first do a fixed
interface modal analysis and request <span
class="math inline">20 × 3 = 60</span> modes (for ensuring accuracy of
the first 20 modes). We fix all the nodes in the nodesets <code
class="verbatim">TOPS_NDS</code> and <code
class="verbatim">BOTS_NDS</code>.</p>
<div class="sourceCode" id="cb15" data-startFrom=""><pre
class="sourceCode numberSource python numberLines continuedSourceBlock"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a><span class="co"># 7. Create a Frequency Step for fixed interface modal analysis</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>mdl.FrequencyStep(name<span class="op">=</span><span class="st">&quot;Fixed-Int-Modal&quot;</span>, previous<span class="op">=</span><span class="st">&quot;Initial&quot;</span>,</span>
<span id="cb15-3"><a href="#cb15-3"></a>                  normalization<span class="op">=</span>MASS, eigensolver<span class="op">=</span>LANCZOS,</span>
<span id="cb15-4"><a href="#cb15-4"></a>                  numEigen<span class="op">=</span><span class="dv">60</span>)</span>
<span id="cb15-5"><a href="#cb15-5"></a>mdl.EncastreBC(name<span class="op">=</span><span class="st">&quot;TOPFIX&quot;</span>, createStepName<span class="op">=</span><span class="st">&quot;Fixed-Int-Modal&quot;</span>,</span>
<span id="cb15-6"><a href="#cb15-6"></a>               region<span class="op">=</span>ras.sets[<span class="st">&#39;TOPS_NDS&#39;</span>])</span>
<span id="cb15-7"><a href="#cb15-7"></a>mdl.EncastreBC(name<span class="op">=</span><span class="st">&quot;BOTFIX&quot;</span>, createStepName<span class="op">=</span><span class="st">&quot;Fixed-Int-Modal&quot;</span>,</span>
<span id="cb15-8"><a href="#cb15-8"></a>               region<span class="op">=</span>ras.sets[<span class="st">&#39;BOTS_NDS&#39;</span>])</span></code></pre></div></li>
<li><p>Next, we create the substructuring step and re-specify the bolt
loads (these were removed in #6 above). The bolt loads are specified of
unit magnitude and can be scaled during analysis. <strong>This by
default uses the mode shapes from the previous step and calculates
static constraint modes automatically.</strong></p>
<div class="sourceCode" id="cb16" data-startFrom=""><pre
class="sourceCode numberSource python numberLines continuedSourceBlock"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a><span class="co"># 8. Create a substructuring step, specify the modes and retained DOFs</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>mdl.SubstructureGenerateStep(name<span class="op">=</span><span class="st">&quot;HCBCMS&quot;</span>, previous<span class="op">=</span><span class="st">&quot;Fixed-Int-Modal&quot;</span>,</span>
<span id="cb16-3"><a href="#cb16-3"></a>                             substructureIdentifier<span class="op">=</span><span class="dv">1</span>, </span>
<span id="cb16-4"><a href="#cb16-4"></a>                             retainedEigenmodesMethod<span class="op">=</span>MODE_RANGE,</span>
<span id="cb16-5"><a href="#cb16-5"></a>                             modeRange<span class="op">=</span>((<span class="dv">1</span>, <span class="dv">20</span>, <span class="dv">1</span>),),</span>
<span id="cb16-6"><a href="#cb16-6"></a>                             recoveryMatrix<span class="op">=</span>REGION,</span>
<span id="cb16-7"><a href="#cb16-7"></a>                             recoveryRegion<span class="op">=</span>ras.sets[<span class="st">&#39;OutNodes&#39;</span>],</span>
<span id="cb16-8"><a href="#cb16-8"></a>                             computeReducedMassMatrix<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-9"><a href="#cb16-9"></a></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="co"># The name dictates ordering. A comes before B.</span></span>
<span id="cb16-11"><a href="#cb16-11"></a>mdl.RetainedNodalDofsBC(name<span class="op">=</span><span class="st">&quot;A&quot;</span>, createStepName<span class="op">=</span><span class="st">&quot;HCBCMS&quot;</span>, </span>
<span id="cb16-12"><a href="#cb16-12"></a>                        region<span class="op">=</span>ras.sets[<span class="st">&#39;TOPS_NDS&#39;</span>], </span>
<span id="cb16-13"><a href="#cb16-13"></a>                        u1<span class="op">=</span>ON, u2<span class="op">=</span>ON, u3<span class="op">=</span>ON)</span>
<span id="cb16-14"><a href="#cb16-14"></a>mdl.RetainedNodalDofsBC(name<span class="op">=</span><span class="st">&quot;B&quot;</span>, createStepName<span class="op">=</span><span class="st">&quot;HCBCMS&quot;</span>, </span>
<span id="cb16-15"><a href="#cb16-15"></a>                        region<span class="op">=</span>ras.sets[<span class="st">&#39;BOTS_NDS&#39;</span>], </span>
<span id="cb16-16"><a href="#cb16-16"></a>                        u1<span class="op">=</span>ON, u2<span class="op">=</span>ON, u3<span class="op">=</span>ON)</span>
<span id="cb16-17"><a href="#cb16-17"></a></span>
<span id="cb16-18"><a href="#cb16-18"></a><span class="co"># Apply Bolt Loads (1N magnitude)</span></span>
<span id="cb16-19"><a href="#cb16-19"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">4</span>):</span>
<span id="cb16-20"><a href="#cb16-20"></a>    mdl.ConcentratedForce(name<span class="op">=</span><span class="st">&#39;BoltLoad-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i), createStepName<span class="op">=</span><span class="st">&quot;HCBCMS&quot;</span>,</span>
<span id="cb16-21"><a href="#cb16-21"></a>                          cf3<span class="op">=</span><span class="fl">1.0</span>,</span>
<span id="cb16-22"><a href="#cb16-22"></a>                          region<span class="op">=</span>ras.instances[<span class="st">&#39;BPT-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i)].sets[<span class="st">&#39;Set-1&#39;</span>])</span>
<span id="cb16-23"><a href="#cb16-23"></a>    mdl.ConcentratedForce(name<span class="op">=</span><span class="st">&#39;NutLoad-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i), createStepName<span class="op">=</span><span class="st">&quot;HCBCMS&quot;</span>,</span>
<span id="cb16-24"><a href="#cb16-24"></a>                          cf3<span class="op">=-</span><span class="fl">1.0</span>,</span>
<span id="cb16-25"><a href="#cb16-25"></a>                          region<span class="op">=</span>ras.instances[<span class="st">&#39;NPT-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i)].sets[<span class="st">&#39;Set-1&#39;</span>])</span>
<span id="cb16-26"><a href="#cb16-26"></a></span>
<span id="cb16-27"><a href="#cb16-27"></a>sbs <span class="op">=</span> mdl.steps[<span class="st">&#39;HCBCMS&#39;</span>]</span>
<span id="cb16-28"><a href="#cb16-28"></a>sbs.LoadCase(name<span class="op">=</span><span class="st">&quot;LCASE&quot;</span>,</span>
<span id="cb16-29"><a href="#cb16-29"></a>             loads<span class="op">=</span><span class="bu">tuple</span>((<span class="st">&#39;BoltLoad-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i), <span class="fl">1.0</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">4</span>)) <span class="op">+</span></span>
<span id="cb16-30"><a href="#cb16-30"></a>             <span class="bu">tuple</span>((<span class="st">&#39;NutLoad-</span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>(i), <span class="fl">1.0</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">4</span>)))</span></code></pre></div>
<p>Note, in the above that the ordering of the two sets is controlled by
the name given to the <code>RetainedNodalDofsBC</code> function.
Although the node sets themselves are not sorted, the order in which the
nodesets appear is sorted by default.</p></li>
<li><p>We finally need to request matrix output. <a
href="https://classes.engineering.wustl.edu/2009/spring/mase5513/abaqus/docs/v6.6/books/key/default.htm?startat=ch18abk43.html">Here</a>
is the ABAQUS documentation for the
<code>*Substructure Matrix Output</code> card. Thus far (until version
2023) ABAQUS CAE doesn't support requesting matrix output from
Substructure steps. We have to request this manually in the .inp files.
Thankfully we can write to the keywords directly from CAE. Go to
<code>Model-&gt;Edit Keywords-&gt;Model-1</code> to do this in the GUI.
In scripting, this is known as a "synch" operation, which is done as
follows:</p>
<div class="sourceCode" id="cb17" data-startFrom=""><pre
class="sourceCode numberSource python numberLines continuedSourceBlock"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a><span class="co"># 9. Request substructure matrix outputs</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="co"># ABAQUS CAE doesn&#39;t support this yet (GUI or scripting),</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="co"># so the keywords need to be manually modified.</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>mdl.keywordBlock.synchVersions(storeNodesAndElements<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb17-5"><a href="#cb17-5"></a></span>
<span id="cb17-6"><a href="#cb17-6"></a>li <span class="op">=</span> np.argwhere([mdl.keywordBlock.sieBlocks[i][<span class="dv">0</span>:<span class="dv">20</span>] <span class="op">==</span> <span class="st">&quot;*Retained Nodal Dofs&quot;</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>                  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(mdl.keywordBlock.sieBlocks))])[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb17-8"><a href="#cb17-8"></a>txi <span class="op">=</span> mdl.keywordBlock.sieBlocks[li]</span>
<span id="cb17-9"><a href="#cb17-9"></a>mdl.keywordBlock.replace(li, <span class="st">&quot;*Retained Nodal Dofs, sorted=NO&quot;</span><span class="op">+</span>txi[<span class="dv">20</span>:])</span>
<span id="cb17-10"><a href="#cb17-10"></a></span>
<span id="cb17-11"><a href="#cb17-11"></a>mdl.keywordBlock.insert(<span class="bu">len</span>(mdl.keywordBlock.sieBlocks)<span class="op">-</span><span class="dv">2</span>, </span>
<span id="cb17-12"><a href="#cb17-12"></a>                        <span class="st">&quot;*Substructure Matrix Output, FILE NAME=Modelmats, &quot;</span> <span class="op">+</span></span>
<span id="cb17-13"><a href="#cb17-13"></a>                        <span class="st">&quot;MASS=YES, STIFFNESS=YES, SLOAD=YES, &quot;</span> <span class="op">+</span></span>
<span id="cb17-14"><a href="#cb17-14"></a>                        <span class="st">&quot;RECOVERY MATRIX=YES&quot;</span>)</span></code></pre></div></li>
<li><p>We then create a job and write it to an "inp" file that can be
run from ABAQUS.</p>
<div class="sourceCode" id="cb18" data-startFrom=""><pre
class="sourceCode numberSource python numberLines continuedSourceBlock"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a><span class="co"># 10. Create a job and write an inp file</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>mdb.Job(name<span class="op">=</span><span class="st">&quot;Job&quot;</span>, model<span class="op">=</span><span class="st">&#39;Model-1&#39;</span>)</span>
<span id="cb18-3"><a href="#cb18-3"></a>mdb.jobs[<span class="st">&#39;Job&#39;</span>].writeInput()</span></code></pre></div></li>
<li><p>Here is what the final HCBCMS step looks like in this case. The
most important part is the <code>*Substructure Matrix Output</code> card
in the bottom, which we introduced through the "synch" step in #3 above.
<a
href="https://classes.engineering.wustl.edu/2009/spring/mase5513/abaqus/docs/v6.6/books/key/default.htm?startat=ch18abk43.html">Here</a>
is the ABAQUS documentation for the
<code>*Substructure Matrix Output</code> card.</p>
<div class="sourceCode" id="cb19" data-startFrom=""><pre
class="sourceCode numberSource fortran numberLines"><code class="sourceCode fortranfixed"><span id="cb19-1"><a href="#cb19-1"></a><span class="co">** ----------------------------------------------------------------</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="co">** </span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="co">** STEP: HCBCMS</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="co">** </span></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="co">*Step, name=HCBCMS, nlgeom=NO</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="co">*Substructure Generate, overwrite, type=Z1, recovery matrix=YES,</span></span>
<span id="cb19-7"><a href="#cb19-7"></a>      nset<span class="kw">=</span>OutNodes, mass matrix<span class="kw">=</span>YES</span>
<span id="cb19-8"><a href="#cb19-8"></a><span class="co">*Select Eigenmodes, generate</span></span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="dv">1</span>, <span class="dv">20</span>, <span class="dv">1</span></span>
<span id="cb19-10"><a href="#cb19-10"></a><span class="co">*Damping Controls, structural=COMBINED, viscous=COMBINED</span></span>
<span id="cb19-11"><a href="#cb19-11"></a><span class="co">*Retained Nodal Dofs, sorted=NO</span></span>
<span id="cb19-12"><a href="#cb19-12"></a>BOTS_NDS, <span class="dv">1</span>, <span class="dv">3</span></span>
<span id="cb19-13"><a href="#cb19-13"></a>TOPS_NDS, <span class="dv">1</span>, <span class="dv">3</span></span>
<span id="cb19-14"><a href="#cb19-14"></a><span class="co">** </span></span>
<span id="cb19-15"><a href="#cb19-15"></a><span class="co">** LOAD CASES</span></span>
<span id="cb19-16"><a href="#cb19-16"></a><span class="co">** </span></span>
<span id="cb19-17"><a href="#cb19-17"></a><span class="co">*Substructure Load Case, name=LCASE</span></span>
<span id="cb19-18"><a href="#cb19-18"></a><span class="co">** Name: BoltLoad-1   Type: Concentrated force   Scale factor: 1</span></span>
<span id="cb19-19"><a href="#cb19-19"></a><span class="co">*Cload</span></span>
<span id="cb19-20"><a href="#cb19-20"></a>BPT<span class="kw">-</span><span class="dv">1_Set</span><span class="kw">-</span><span class="dv">1</span>, <span class="dv">3</span>, <span class="fl">1.</span></span>
<span id="cb19-21"><a href="#cb19-21"></a><span class="co">** Name: BoltLoad-2   Type: Concentrated force   Scale factor: 1</span></span>
<span id="cb19-22"><a href="#cb19-22"></a><span class="co">*Cload</span></span>
<span id="cb19-23"><a href="#cb19-23"></a>BPT<span class="kw">-</span><span class="dv">2_Set</span><span class="kw">-</span><span class="dv">1</span>, <span class="dv">3</span>, <span class="fl">1.</span></span>
<span id="cb19-24"><a href="#cb19-24"></a><span class="co">** Name: BoltLoad-3   Type: Concentrated force   Scale factor: 1</span></span>
<span id="cb19-25"><a href="#cb19-25"></a><span class="co">*Cload</span></span>
<span id="cb19-26"><a href="#cb19-26"></a>BPT<span class="kw">-</span><span class="dv">3_Set</span><span class="kw">-</span><span class="dv">1</span>, <span class="dv">3</span>, <span class="fl">1.</span></span>
<span id="cb19-27"><a href="#cb19-27"></a><span class="co">** Name: NutLoad-1   Type: Concentrated force   Scale factor: 1</span></span>
<span id="cb19-28"><a href="#cb19-28"></a><span class="co">*Cload</span></span>
<span id="cb19-29"><a href="#cb19-29"></a>NPT<span class="kw">-</span><span class="dv">1_Set</span><span class="kw">-</span><span class="dv">1</span>, <span class="dv">3</span>, <span class="kw">-</span><span class="fl">1.</span></span>
<span id="cb19-30"><a href="#cb19-30"></a><span class="co">** Name: NutLoad-2   Type: Concentrated force   Scale factor: 1</span></span>
<span id="cb19-31"><a href="#cb19-31"></a><span class="co">*Cload</span></span>
<span id="cb19-32"><a href="#cb19-32"></a>NPT<span class="kw">-</span><span class="dv">2_Set</span><span class="kw">-</span><span class="dv">1</span>, <span class="dv">3</span>, <span class="kw">-</span><span class="fl">1.</span></span>
<span id="cb19-33"><a href="#cb19-33"></a><span class="co">** Name: NutLoad-3   Type: Concentrated force   Scale factor: 1</span></span>
<span id="cb19-34"><a href="#cb19-34"></a><span class="co">*Cload</span></span>
<span id="cb19-35"><a href="#cb19-35"></a>NPT<span class="kw">-</span><span class="dv">3_Set</span><span class="kw">-</span><span class="dv">1</span>, <span class="dv">3</span>, <span class="kw">-</span><span class="fl">1.</span></span>
<span id="cb19-36"><a href="#cb19-36"></a><span class="co">*Substructure Matrix Output, FILE NAME=Modelmats, MASS=YES,</span></span>
<span id="cb19-37"><a href="#cb19-37"></a>      STIFFNESS<span class="kw">=</span>YES, SLOAD<span class="kw">=</span>YES, RECOVERY MATRIX<span class="kw">=</span>YES</span>
<span id="cb19-38"><a href="#cb19-38"></a><span class="co">*End Step</span></span></code></pre></div>
<p>You can find the inp-file generate from the above in <a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/assets/demo/Job.inp">Job.inp</a>.</p></li>
</ol>
<h2 id="run-job-and-generate-the-mtx-file.">Run Job and Generate the mtx
file. <span class="tag" data-tag-name="Script"><span
class="smallcaps">Script</span></span> <span class="tag"
data-tag-name="GUI"><span class="smallcaps">GUI</span></span></h2>
<p>You can now run the Job named "Job" in the GUI, or directly run the
"<a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/assets/demo/Job.inp">Job.inp</a>"
file from the command line using</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ex">abaqus</span> job=Job inp=Job.inp cpus=2 interactive</span></code></pre></div>
<p>Once the job is done, it will output the matrix file "Modelmats.mtx"
into the working directory. This, along with the "Nodes.dat" and
"Elements.dat" files that were written out earlier, are all we need for
external analyses.</p>
<h1 id="matrix-extraction-nl-analysis">Matrix Extraction +
NL-Analysis</h1>
<p>By default, ABAQUS uses the <a
href="https://math.nist.gov/MatrixMarket/">matrix market format</a> for
the outputted matrices. Note the following, in terms of format:</p>
<ul>
<li>Each line that starts with an asterix ("*") is a comment.</li>
<li>The linear matrices of the current model are fully symmetric.</li>
<li>So only the upper triangular parts of the matrices are
exported.</li>
<li>The load vector is exported as a vector.</li>
<li>Columns of the recovery matrix <span
class="math inline"><em>R</em></span>, defined by <span
class="math display"><em>x</em><sub><em>o</em><em>u</em><em>t</em></sub> = <em>R</em><em>x</em><sub><em>c</em><em>m</em><em>s</em></sub></span>
where <span
class="math inline"><em>x</em><sub><em>c</em><em>m</em><em>s</em></sub></span>
is the vector of DOFs of the CMS model (substructure) and <span
class="math inline"><em>x</em><sub><em>o</em><em>u</em><em>t</em></sub></span>
are the output DOFs. Each column of <span
class="math inline"><em>R</em></span> is <span
class="math inline"><em>N</em><sub><em>o</em><em>u</em><em>t</em></sub> × 1</span>,
and <span class="math inline"><em>R</em></span> is <span
class="math inline"><em>N</em><sub><em>o</em><em>u</em><em>t</em></sub> × <em>N</em><sub><em>c</em><em>m</em><em>s</em></sub></span>.</li>
</ul>
<h2 id="postprocessing-exported-matrices">Postprocessing Exported
Matrices <span class="tag" data-tag-name="Script"><span
class="smallcaps">Script</span></span></h2>
<ol>
<li><p>The first few lines provide the generalized coordinates of the
model. The nodes are listed as positive integers and the "modal" DOFs
are listed as negative integers. This is followed by a list of DOFs
active in each set.</p></li>
<li><p>The STIFFNESS and MASS matrices are respectively prepended by</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode fortran"><code class="sourceCode fortranfixed"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">*     MATRIX,TYPE=STIFFNESS</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;</span>Stiffness matrix entries in upper triangular form<span class="op">&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co">*     MATRIX,TYPE=MASS</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;</span>Mass matrix entries in upper triangular form<span class="op">&gt;</span>      </span></code></pre></div></li>
<li><p>The load vector (the bolt prestress load, here) is written
as,</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode fortran"><code class="sourceCode fortranfixed"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">** SUBSTRUCTURE LOAD CASE VECTOR. SLOAD CASE &lt;name&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co">***CLOAD </span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">** 1, 1, &lt;entry&gt;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">** 1, 2, &lt;entry&gt;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="co">** 1, 3, &lt;entry&gt;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>      .</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>      .</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>      .</span></code></pre></div></li>
<li><p>Finally, the recovery matrix is provided row-by-row as</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode fortran"><code class="sourceCode fortranfixed"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">*     SUBSTRUCTURE RECOVERY VECTOR CORRESPONDING TO RETAINED DOFS NUMBER 1</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;</span>entries<span class="op">&gt;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">*     SUBSTRUCTURE RECOVERY VECTOR CORRESPONDING TO RETAINED DOFS NUMBER 2</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;</span>entries<span class="op">&gt;</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>      .</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>      .</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>      .</span></code></pre></div></li>
<li><p>In the actual file, the order is STIFFNESS, LOAD, MASS, then
SUBSTRUCTURE.</p></li>
<li><p>The following Bash script processes the output (a stiffness, a
mass, a load case, and recovery entries are expected)</p>
<div class="sourceCode" id="cb24" data-startFrom=""><pre
class="sourceCode numberSource bash numberLines"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1"></a><span class="co">#!/bin/sh</span></span>
<span id="cb24-2"><a href="#cb24-2"></a></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="cf">if</span> <span class="bu">[</span> <span class="va">$#</span> <span class="ot">=</span> 2 <span class="bu">]</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="cf">then</span> </span>
<span id="cb24-5"><a href="#cb24-5"></a>    <span class="bu">echo</span> <span class="st">&quot;Correct call!&quot;</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>    <span class="va">OUT</span><span class="op">=</span><span class="va">$2</span></span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="cf">elif</span> <span class="bu">[</span> <span class="va">$#</span> <span class="ot">=</span> 1 <span class="bu">]</span></span>
<span id="cb24-8"><a href="#cb24-8"></a><span class="cf">then</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>    <span class="bu">echo</span> <span class="st">&quot;Acceptable call!&quot;</span></span>
<span id="cb24-10"><a href="#cb24-10"></a>    <span class="va">a</span><span class="op">=</span><span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span></span>
<span id="cb24-11"><a href="#cb24-11"></a>    <span class="va">OUT</span><span class="op">=</span><span class="st">&quot;</span><span class="va">${a</span><span class="op">%</span>.<span class="pp">*</span><span class="va">}</span><span class="st">.mat&quot;</span></span>
<span id="cb24-12"><a href="#cb24-12"></a><span class="cf">else</span></span>
<span id="cb24-13"><a href="#cb24-13"></a>    <span class="bu">echo</span> <span class="st">&quot;Wrong call - quitting!&quot;</span></span>
<span id="cb24-14"><a href="#cb24-14"></a><span class="cf">fi</span></span>
<span id="cb24-15"><a href="#cb24-15"></a><span class="bu">echo</span> <span class="st">&quot;Preprocessing mtx files&quot;</span></span>
<span id="cb24-16"><a href="#cb24-16"></a><span class="va">awkcmd1</span><span class="op">=</span><span class="st">&#39;BEGIN{mstart=0;}</span></span>
<span id="cb24-17"><a href="#cb24-17"></a><span class="st">  ($1~/^\*M/){mstart++; next}</span></span>
<span id="cb24-18"><a href="#cb24-18"></a><span class="st">  (mstart==1){if($1!~/^\*/){print}else{exit}}&#39;</span></span>
<span id="cb24-19"><a href="#cb24-19"></a><span class="va">awkcmd2</span><span class="op">=</span><span class="st">&#39;BEGIN{RS=&quot;,&quot;;ORS=&quot;\n&quot;}{print}&#39;</span></span>
<span id="cb24-20"><a href="#cb24-20"></a><span class="fu">gawk</span> <span class="st">&quot;</span><span class="va">$awkcmd1</span><span class="st">&quot;</span> <span class="va">$1</span><span class="kw">|</span><span class="fu">gawk</span> <span class="st">&quot;</span><span class="va">$awkcmd2</span><span class="st">&quot;</span><span class="kw">|</span><span class="fu">gawk</span> <span class="st">&#39;(NF!=0){print}&#39;</span> <span class="op">&gt;</span> ./.STIFFNESS.mtx</span>
<span id="cb24-21"><a href="#cb24-21"></a></span>
<span id="cb24-22"><a href="#cb24-22"></a><span class="va">awkcmd1</span><span class="op">=</span><span class="st">&#39;BEGIN{mstart=0;}</span></span>
<span id="cb24-23"><a href="#cb24-23"></a><span class="st">  ($1~/^\*M/){mstart++; next}</span></span>
<span id="cb24-24"><a href="#cb24-24"></a><span class="st">  (mstart==2){if($1!~/^\*/){print}else{exit}}&#39;</span></span>
<span id="cb24-25"><a href="#cb24-25"></a><span class="va">awkcmd2</span><span class="op">=</span><span class="st">&#39;BEGIN{RS=&quot;,&quot;;ORS=&quot;\n&quot;}{print}&#39;</span></span>
<span id="cb24-26"><a href="#cb24-26"></a><span class="fu">gawk</span> <span class="st">&quot;</span><span class="va">$awkcmd1</span><span class="st">&quot;</span> <span class="va">$1</span><span class="kw">|</span><span class="fu">gawk</span> <span class="st">&quot;</span><span class="va">$awkcmd2</span><span class="st">&quot;</span><span class="kw">|</span><span class="fu">gawk</span> <span class="st">&#39;(NF!=0){print}&#39;</span> <span class="op">&gt;</span> ./.MASS.mtx</span>
<span id="cb24-27"><a href="#cb24-27"></a></span>
<span id="cb24-28"><a href="#cb24-28"></a><span class="va">awkcmd1</span><span class="op">=</span><span class="st">&#39;BEGIN{vstart=0;}</span></span>
<span id="cb24-29"><a href="#cb24-29"></a><span class="st">  ($0~/^\*\*\*C/){vstart++; next}</span></span>
<span id="cb24-30"><a href="#cb24-30"></a><span class="st">  (vstart&gt;0){print $2,$3,$4}</span></span>
<span id="cb24-31"><a href="#cb24-31"></a><span class="st">  (vstart&gt;0 &amp;&amp; $1!~/^\*\*/){exit}&#39;</span></span>
<span id="cb24-32"><a href="#cb24-32"></a><span class="va">awkcmd2</span><span class="op">=</span><span class="st">&#39;BEGIN{FS=&quot;,&quot;}</span></span>
<span id="cb24-33"><a href="#cb24-33"></a><span class="st">  {for(i=1;i&lt;=NF;i++)</span></span>
<span id="cb24-34"><a href="#cb24-34"></a><span class="st">    printf(&quot;%s &quot;, $i);</span></span>
<span id="cb24-35"><a href="#cb24-35"></a><span class="st">    printf(&quot;\n&quot;)}&#39;</span></span>
<span id="cb24-36"><a href="#cb24-36"></a><span class="fu">gawk</span> <span class="st">&quot;</span><span class="va">$awkcmd1</span><span class="st">&quot;</span> <span class="va">$1</span><span class="kw">|</span><span class="fu">gawk</span> <span class="st">&quot;</span><span class="va">$awkcmd2</span><span class="st">&quot;</span> <span class="op">&gt;</span> ./.FVEC.mtx</span>
<span id="cb24-37"><a href="#cb24-37"></a></span>
<span id="cb24-38"><a href="#cb24-38"></a><span class="va">awkcmd1</span><span class="op">=</span><span class="st">&#39;BEGIN{rstart=0}</span></span>
<span id="cb24-39"><a href="#cb24-39"></a><span class="st"> ($0~/^\*\* SUBSTRUCTURE REC/){rstart++;</span></span>
<span id="cb24-40"><a href="#cb24-40"></a><span class="st"> if(rstart&gt;1){printf(&quot;\n&quot;)}</span></span>
<span id="cb24-41"><a href="#cb24-41"></a><span class="st"> next}</span></span>
<span id="cb24-42"><a href="#cb24-42"></a><span class="st"> (rstart!=0 &amp;&amp; $1~/\*\*/){</span></span>
<span id="cb24-43"><a href="#cb24-43"></a><span class="st"> for(i=2;i&lt;=NF;i++)printf(&quot;%s&quot;,$i);}&#39;</span></span>
<span id="cb24-44"><a href="#cb24-44"></a><span class="va">awkcmd2</span><span class="op">=</span><span class="st">&#39;BEGIN{FS=&quot;,&quot;}</span></span>
<span id="cb24-45"><a href="#cb24-45"></a><span class="st">  {for(i=1;i&lt;=NF;i++)</span></span>
<span id="cb24-46"><a href="#cb24-46"></a><span class="st">    printf(&quot;%s &quot;,$i);</span></span>
<span id="cb24-47"><a href="#cb24-47"></a><span class="st">    printf(&quot;\n&quot;);}&#39;</span></span>
<span id="cb24-48"><a href="#cb24-48"></a><span class="fu">gawk</span> <span class="st">&quot;</span><span class="va">$awkcmd1</span><span class="st">&quot;</span> <span class="va">$1</span><span class="kw">|</span><span class="fu">gawk</span> <span class="st">&quot;</span><span class="va">$awkcmd2</span><span class="st">&quot;</span> <span class="op">&gt;</span> .RECOV.mtx</span>
<span id="cb24-49"><a href="#cb24-49"></a></span>
<span id="cb24-50"><a href="#cb24-50"></a><span class="bu">echo</span> <span class="st">&quot;Preprocessing mtx files done&quot;</span></span>
<span id="cb24-51"><a href="#cb24-51"></a></span>
<span id="cb24-52"><a href="#cb24-52"></a><span class="ex">python</span> <span class="op">&lt;&lt;EOF</span></span>
<span id="cb24-53"><a href="#cb24-53"></a><span class="st">import numpy as np</span></span>
<span id="cb24-54"><a href="#cb24-54"></a><span class="st">import scipy.io as io</span></span>
<span id="cb24-55"><a href="#cb24-55"></a></span>
<span id="cb24-56"><a href="#cb24-56"></a><span class="st">print(&quot;Reading Mass Matrix from mtx file.&quot;);</span></span>
<span id="cb24-57"><a href="#cb24-57"></a><span class="st">Mv = np.loadtxt(&#39;.MASS.mtx&#39;);</span></span>
<span id="cb24-58"><a href="#cb24-58"></a><span class="st">print(&quot;Done.&quot;);</span></span>
<span id="cb24-59"><a href="#cb24-59"></a></span>
<span id="cb24-60"><a href="#cb24-60"></a><span class="st">print(&quot;Reading Stiffness Matrix from mtx file.&quot;);</span></span>
<span id="cb24-61"><a href="#cb24-61"></a><span class="st">Kv = np.loadtxt(&#39;.STIFFNESS.mtx&#39;);</span></span>
<span id="cb24-62"><a href="#cb24-62"></a><span class="st">print(&quot;Done.&quot;);</span></span>
<span id="cb24-63"><a href="#cb24-63"></a></span>
<span id="cb24-64"><a href="#cb24-64"></a><span class="st">print(&quot;Reading Recovery Matrix from mtx file.&quot;);</span></span>
<span id="cb24-65"><a href="#cb24-65"></a><span class="st">R = np.loadtxt(&#39;.RECOV.mtx&#39;);</span></span>
<span id="cb24-66"><a href="#cb24-66"></a><span class="st">print(&quot;Done.&quot;);</span></span>
<span id="cb24-67"><a href="#cb24-67"></a></span>
<span id="cb24-68"><a href="#cb24-68"></a><span class="st">print(&quot;Processing Matrices.&quot;)</span></span>
<span id="cb24-69"><a href="#cb24-69"></a></span>
<span id="cb24-70"><a href="#cb24-70"></a><span class="st">Nelm = len(Mv);</span></span>
<span id="cb24-71"><a href="#cb24-71"></a><span class="st">Nelk = len(Kv);</span></span>
<span id="cb24-72"><a href="#cb24-72"></a><span class="st">if (Nelm!=Nelk):</span></span>
<span id="cb24-73"><a href="#cb24-73"></a><span class="st">        sys.exit(&quot;GIGO - Mass &amp; Stiffness not of same length.&quot;);</span></span>
<span id="cb24-74"><a href="#cb24-74"></a><span class="st">Nel = Nelm;</span></span>
<span id="cb24-75"><a href="#cb24-75"></a></span>
<span id="cb24-76"><a href="#cb24-76"></a><span class="st">Nd = ((np.sqrt(1+8*Nel)-1)/2).astype(int); # Solution of Nd(Nd+1)/2-Nel = 0</span></span>
<span id="cb24-77"><a href="#cb24-77"></a></span>
<span id="cb24-78"><a href="#cb24-78"></a><span class="st">M = np.zeros((Nd,Nd));</span></span>
<span id="cb24-79"><a href="#cb24-79"></a><span class="st">K = np.zeros((Nd,Nd));</span></span>
<span id="cb24-80"><a href="#cb24-80"></a></span>
<span id="cb24-81"><a href="#cb24-81"></a><span class="st">(xi,yi) = np.tril_indices(Nd);</span></span>
<span id="cb24-82"><a href="#cb24-82"></a><span class="st">M[xi,yi] = Mv;</span></span>
<span id="cb24-83"><a href="#cb24-83"></a><span class="st">M[yi,xi] = Mv;</span></span>
<span id="cb24-84"><a href="#cb24-84"></a><span class="st">K[xi,yi] = Kv;</span></span>
<span id="cb24-85"><a href="#cb24-85"></a><span class="st">K[yi,xi] = Kv;</span></span>
<span id="cb24-86"><a href="#cb24-86"></a></span>
<span id="cb24-87"><a href="#cb24-87"></a><span class="st">print(&quot;Done.&quot;)</span></span>
<span id="cb24-88"><a href="#cb24-88"></a></span>
<span id="cb24-89"><a href="#cb24-89"></a><span class="st">print(&quot;Reading Forcing Vector from mtx file.&quot;);</span></span>
<span id="cb24-90"><a href="#cb24-90"></a><span class="st">Fvdat = np.loadtxt(&#39;.FVEC.mtx&#39;);</span></span>
<span id="cb24-91"><a href="#cb24-91"></a><span class="st">print(&quot;Done.&quot;);</span></span>
<span id="cb24-92"><a href="#cb24-92"></a></span>
<span id="cb24-93"><a href="#cb24-93"></a><span class="st">print(&quot;Processing Force Vector.&quot;);</span></span>
<span id="cb24-94"><a href="#cb24-94"></a><span class="st">Fv = np.zeros(M.shape[0]);</span></span>
<span id="cb24-95"><a href="#cb24-95"></a><span class="st">ids = range(np.where(np.diff(Fvdat[:, 1])==0)[0][0], Fvdat.shape[0])</span></span>
<span id="cb24-96"><a href="#cb24-96"></a><span class="st">n1dofnds = Fvdat[ids, 0].astype(int)</span></span>
<span id="cb24-97"><a href="#cb24-97"></a><span class="st">n3dofnds = Fvdat[list(set(range(Fvdat.shape[0]))-set(ids)), 0].astype(int)</span></span>
<span id="cb24-98"><a href="#cb24-98"></a><span class="st">Fv[((n3dofnds-1)*3+np.kron(np.ones(int(len(n3dofnds)/3)),[0, 1, 2])).astype(int)] = </span><span class="dt">\</span></span>
<span id="cb24-99"><a href="#cb24-99"></a><span class="st">Fvdat[list(set(range(Fvdat.shape[0]))-set(ids)), 2]</span></span>
<span id="cb24-100"><a href="#cb24-100"></a><span class="st">print(&quot;Whew.&quot;)</span></span>
<span id="cb24-101"><a href="#cb24-101"></a><span class="st">Fv[range(-len(n1dofnds), 0)] = Fvdat[ids, 2]</span></span>
<span id="cb24-102"><a href="#cb24-102"></a><span class="st">print(&quot;Done.&quot;)</span></span>
<span id="cb24-103"><a href="#cb24-103"></a></span>
<span id="cb24-104"><a href="#cb24-104"></a><span class="st">print(&quot;Matrix extraction complete - writing mat file&quot;)</span></span>
<span id="cb24-105"><a href="#cb24-105"></a><span class="st">dict = {&quot;M&quot;: M, &quot;K&quot;: K, &quot;R&quot;: R.T, &quot;Fv&quot;: Fv.reshape((len(Fv),1))};</span></span>
<span id="cb24-106"><a href="#cb24-106"></a><span class="st">io.savemat(&quot;.out.mat&quot;,dict);</span></span>
<span id="cb24-107"><a href="#cb24-107"></a><span class="st">print(&quot;Processing Over&quot;)</span></span>
<span id="cb24-108"><a href="#cb24-108"></a><span class="op">EOF</span></span>
<span id="cb24-109"><a href="#cb24-109"></a><span class="fu">mv</span> .out.mat <span class="va">$OUT</span></span>
<span id="cb24-110"><a href="#cb24-110"></a><span class="fu">rm</span> .STIFFNESS.mtx .MASS.mtx .RECOV.mtx .FVEC.mtx</span></code></pre></div>
<ul>
<li><p>This bash script first uses <a
href="https://www.gnu.org/software/gawk/manual/gawk.html">GNU Awk</a>, a
simple but powerful utility that allows line-by-line parsing of
files.</p></li>
<li><p>The script also uses the <a
href="https://www.gnu.org/software/coreutils/cut">cut</a> utility from
<a href="https://www.gnu.org/software/coreutils/cut">GNU coreutils</a>
for manipulations.</p></li>
<li><p>Finally, the script uses Python (compatible with 2/3), involving
numpy and scipy.io, for converting the quantities into a MATLAB mat-file
that can be loaded on MATLAB.</p></li>
<li><p>This script can be called as follows:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./readwritematvec.sh</span> Modelmats.mtx</span></code></pre></div></li>
<li><p>In windows, this can be done either through <a
href="https://www.cygwin.com/">Cygwin</a> or <a
href="https://learn.microsoft.com/en-us/windows/wsl/install">Windows
Subsystem for Linux</a>.</p></li>
</ul></li>
<li><p>It may be possible to do this natively in MATLAB, but since this
requires a line-parser, awk is better suited for the job than MATLAB. A
MATLAB implementation might require loading the whole file into memory
for speed. Line-parsing on MATLAB was extremely slow for me.</p></li>
</ol>
<p>The file <a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/assets/assembly/model_step3.cae">model<sub>step3</sub>.cae</a>
is the final cae file that contains all of the above.</p>
<h2
id="nonlinear-analysis-on-matlaboctave-in-under-100-lines-of-code">Nonlinear
Analysis on MATLAB/OCTAVE in under 100 lines of code <span class="tag"
data-tag-name="Script"><span class="smallcaps">Script</span></span></h2>
<p>We will now do our first nonlinear analysis on MATLAB/OCTAVE with the
exported matrices. We will conduct a <strong>Nonlinear Prestress
Analysis</strong> for a frictionless contact with a unilateral spring on
the normal direction.</p>
<p>It is assumed that the <a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/scripts/readwritematvec.sh">readwritematvec.sh</a>
routine has been called on matrix file named <code>Modelmats.mtx</code>
to produce <code>Modelmats.mat</code> mat-file. Further, the nodes and
elements on the interface are taken to be available in
<code>Nodes.dat</code> and <code>Elements.dat</code> files respectively.
The below tutorial is meant to be minimal so it is assumed that all the
elements are linear QUAD elements.</p>
<ol>
<li><p>We start with the preamble for the MATLAB file, then read the
mesh information, and then load up the matrices from the
<code>Modelmats.mat</code> file.</p>
<div class="sourceCode" id="cb26" data-startFrom=""><pre
class="sourceCode numberSource octave numberLines"><code class="sourceCode octave"><span id="cb26-1"><a href="#cb26-1"></a><span class="fu">clc</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="bu">clear</span> <span class="fu">all</span></span>
<span id="cb26-3"><a href="#cb26-3"></a></span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="fu">set</span>(<span class="fl">0</span><span class="op">,</span><span class="st">&#39;defaultAxesTickLabelInterpreter&#39;</span><span class="op">,</span> <span class="st">&#39;default&#39;</span>)<span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5"></a><span class="fu">set</span>(<span class="fl">0</span><span class="op">,</span><span class="st">&#39;defaultTextInterpreter&#39;</span><span class="op">,</span><span class="st">&#39;latex&#39;</span>)<span class="op">;</span></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="fu">set</span>(<span class="fl">0</span><span class="op">,</span> <span class="st">&#39;DefaultLegendInterpreter&#39;</span><span class="op">,</span> <span class="st">&#39;latex&#39;</span>)<span class="op">;</span></span>
<span id="cb26-7"><a href="#cb26-7"></a><span class="fu">set</span>(<span class="fl">0</span><span class="op">,</span><span class="st">&#39;defaultAxesFontSize&#39;</span><span class="op">,</span><span class="fl">13</span>)<span class="op">;</span></span>
<span id="cb26-8"><a href="#cb26-8"></a></span>
<span id="cb26-9"><a href="#cb26-9"></a><span class="co">%% Read Nodes and Elements</span></span>
<span id="cb26-10"><a href="#cb26-10"></a>Nodes <span class="op">=</span> <span class="fu">dlmread</span>(<span class="st">&#39;./Nodes.dat&#39;</span>)<span class="op">;</span></span>
<span id="cb26-11"><a href="#cb26-11"></a>Elements <span class="op">=</span> <span class="fu">dlmread</span>(<span class="st">&#39;./Elements.dat&#39;</span>)<span class="op">;</span></span>
<span id="cb26-12"><a href="#cb26-12"></a>N <span class="op">=</span> <span class="fu">size</span>(Nodes<span class="op">,</span><span class="fl">1</span>)<span class="op">;</span>  <span class="co">% Number of nodes per side</span></span>
<span id="cb26-13"><a href="#cb26-13"></a>Ne <span class="op">=</span> <span class="fu">size</span>(Elements<span class="op">,</span><span class="fl">1</span>)<span class="op">;</span>  <span class="co">% Number of elements</span></span>
<span id="cb26-14"><a href="#cb26-14"></a></span>
<span id="cb26-15"><a href="#cb26-15"></a><span class="co">%% Load Matrices</span></span>
<span id="cb26-16"><a href="#cb26-16"></a>fname <span class="op">=</span> <span class="st">&#39;./Modelmats.mat&#39;</span><span class="op">;</span></span>
<span id="cb26-17"><a href="#cb26-17"></a><span class="bu">load</span>(fname<span class="op">,</span> <span class="st">&#39;M&#39;</span><span class="op">,</span> <span class="st">&#39;K&#39;</span><span class="op">,</span> <span class="st">&#39;R&#39;</span><span class="op">,</span> <span class="st">&#39;Fv&#39;</span>)<span class="op">;</span></span>
<span id="cb26-18"><a href="#cb26-18"></a></span>
<span id="cb26-19"><a href="#cb26-19"></a><span class="co">% Number of generalized modal DOFs</span></span>
<span id="cb26-20"><a href="#cb26-20"></a>Nint <span class="op">=</span> <span class="fu">size</span>(M<span class="op">,</span><span class="fl">1</span>)<span class="op">-</span>(<span class="fl">2</span><span class="op">*</span>N)<span class="op">*</span><span class="fl">3</span><span class="op">;</span></span></code></pre></div></li>
<li><p>It may be tempting to want to use <strong>node-to-node contact
elements</strong>. But this is <strong>inconsistent here</strong> since
the elements have non-uniform area and have non-trivial connectivity. In
the continuous case, the nodal-force-traction relationship is expressed
as <span
class="math display"><em>f</em><sub><em>j</em></sub> = ∫<sub><em>Ω</em></sub>ℕ<sub><em>j</em></sub><em>t</em>(𝕩)<em>d</em><em>Ω</em>,</span>
where <span class="math inline">ℕ<sub><em>j</em></sub></span> is the
<span
class="math inline"><em>j</em><sup><em>t</em><em>h</em></sup></span>
shape function, <span
class="math inline"><em>f</em><sub><em>j</em></sub></span> is the nodal
force of the <span
class="math inline"><em>j</em><sup><em>t</em><em>h</em></sup></span>
node, and <span class="math inline"><em>t</em>(𝕩)</span> is the
traction-field (of the appropriate traction).<br />
<strong>Contact-constitutive models are understood as local
relationships between the relative displacement and contact
tractions.</strong> Nodal forces are merely integral effects of the
local traction distributions.<br />
It is therefore <strong>necessary to employ quadrature
integration</strong> for consistency.</p></li>
<li><p>The implementation greatly simplifies if we were to employ only a
single Quadrature Point (QP) per element. We construct two matrices,
<span class="math inline"><em>Q</em><sub><em>m</em></sub></span> and
<span class="math inline"><em>T</em><sub><em>m</em></sub></span> such
that</p>
<p><span class="math display">$$\begin{align*}
     x_{QP} &amp;= Q_{m} x_N \text{, and}\\
     f_N &amp;= T_{m} t_{QP}.
     \end{align*}$$</span></p>
<p>Here, <span
class="math inline"><em>x</em><sub><em>Q</em><em>P</em></sub></span> and
<span class="math inline"><em>x</em><sub><em>N</em></sub></span> are the
vector of displacements at quadrature points and nodal points
respectively; and <span
class="math inline"><em>f</em><sub><em>N</em></sub></span> and <span
class="math inline"><em>t</em><sub><em>Q</em><em>P</em></sub></span> are
the vector of nodal forces and quadrature point tractions
respectively.</p>
<div class="sourceCode" id="cb27" data-startFrom=""><pre
class="sourceCode numberSource octave numberLines continuedSourceBlock"><code class="sourceCode octave"><span id="cb27-1"><a href="#cb27-1"></a><span class="co">%% Single-Point-Quadrature Matrices</span></span>
<span id="cb27-2"><a href="#cb27-2"></a>Qm <span class="op">=</span> <span class="fu">zeros</span>(Ne<span class="op">,</span> N)<span class="op">;</span>  <span class="co">% Each element has one quadrature point</span></span>
<span id="cb27-3"><a href="#cb27-3"></a>Tm <span class="op">=</span> <span class="fu">zeros</span>(N<span class="op">,</span> Ne)<span class="op">;</span>  <span class="co">% Each quadrature pt integrated to 4 nodes</span></span>
<span id="cb27-4"><a href="#cb27-4"></a>Ars <span class="op">=</span> <span class="fu">zeros</span>(Ne<span class="op">,</span> <span class="fl">1</span>)<span class="op">;</span>  <span class="co">% Vector of areas of each element</span></span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="cf">for</span> ei<span class="op">=</span><span class="fl">1</span><span class="op">:</span>Ne</span>
<span id="cb27-6"><a href="#cb27-6"></a>    ndis <span class="op">=</span> Elements(ei<span class="op">,</span> <span class="fl">2</span><span class="op">:</span><span class="cf">end</span>)<span class="op">;</span>  <span class="co">% Nodes of the current element</span></span>
<span id="cb27-7"><a href="#cb27-7"></a>    Qm(ei<span class="op">,</span> ndis) <span class="op">=</span> <span class="fu">ones</span>(<span class="fl">1</span><span class="op">,</span> <span class="fl">4</span>)<span class="op">/</span><span class="fl">4</span><span class="op">;</span></span>
<span id="cb27-8"><a href="#cb27-8"></a>                <span class="co">% value @ QP = avg of nodal values</span></span>
<span id="cb27-9"><a href="#cb27-9"></a></span>
<span id="cb27-10"><a href="#cb27-10"></a>    Ars(ei) <span class="op">=</span> <span class="fu">polyarea</span>(Nodes(ndis<span class="op">,</span><span class="fl">1</span>)<span class="op">,</span> Nodes(ndis<span class="op">,</span><span class="fl">2</span>))<span class="op">;</span></span>
<span id="cb27-11"><a href="#cb27-11"></a></span>
<span id="cb27-12"><a href="#cb27-12"></a>    Tm(ndis<span class="op">,</span> ei) <span class="op">=</span> <span class="fu">ones</span>(<span class="fl">4</span><span class="op">,</span> <span class="fl">1</span>)<span class="op">*</span>Ars(ei)<span class="op">/</span><span class="fl">4</span><span class="op">;</span></span>
<span id="cb27-13"><a href="#cb27-13"></a>                <span class="co">% (integrated) nodal value = value @ QP times element Area/4</span></span>
<span id="cb27-14"><a href="#cb27-14"></a><span class="cf">end</span></span>
<span id="cb27-15"><a href="#cb27-15"></a><span class="co">% Qm is quadrature interpolation matrix</span></span>
<span id="cb27-16"><a href="#cb27-16"></a><span class="co">% Tm is quadrature integration matrix</span></span>
<span id="cb27-17"><a href="#cb27-17"></a></span>
<span id="cb27-18"><a href="#cb27-18"></a>Ar_tot <span class="op">=</span> <span class="fl">120e-3</span><span class="op">*</span><span class="fl">25.4e-3</span><span class="op">-</span><span class="fl">3</span><span class="op">*</span><span class="bu">pi</span><span class="op">*</span>(<span class="fl">0.85e-2</span><span class="op">/</span><span class="fl">2</span>)<span class="op">^</span><span class="fl">2</span><span class="op">;</span> <span class="co">% True total area</span></span>
<span id="cb27-19"><a href="#cb27-19"></a>                                            <span class="co">% Rectangle-3*Circles</span></span>
<span id="cb27-20"><a href="#cb27-20"></a>Ar_avg <span class="op">=</span> Ar_tot<span class="op">/</span>Ne<span class="op">;</span>  <span class="co">% Average element area</span></span></code></pre></div>
<p>The fact that for a single quadrature point case, the quadrature
point is exactly at the centroid of the element. For the integral, this
assumes that the traction field within each element is uniform, so the
integral may be simplified as <span class="math display">$$ f_j =
\int_{\Omega_e} \mathbb{N}_j t(\mathbb{x}) d\Omega \approxeq t_{QP}
\underbrace{\int_{\Omega_e} \mathbb{N}_j d\Omega}_{A_e/4,} $$</span>
with <span class="math inline"><em>A</em><sub><em>e</em></sub></span>
denoting element area, and <span
class="math inline"><em>Ω</em><sub><em>e</em></sub></span> denoting
element domain (surface). The interpolation and integration weights are,
therefore, easily specified. The following is a depiction of the
quadrature points against the interfacial elements. <img
src="./figs/quadpts.png" /></p></li>
<li><p>We now construct a matrix <span
class="math inline"><em>L</em><sub><em>r</em><em>e</em><em>l</em></sub></span>
such that <span
class="math inline"><em>L</em><sub><em>r</em><em>e</em><em>l</em></sub><em>x</em><sub><em>c</em><em>m</em><em>s</em></sub></span>
gives an <span class="math inline"><em>N</em> × 1</span> array of
interfacial relative displacements in the normal direction. This is
written based on the fact that the CMS model first lists out all the
nodal DOFs of the top interface (<span
class="math inline"><em>x</em>, <em>y</em>, <em>z</em></span>, in that
order), and then lists out the DOFs of the bottom interface nodes. So
the relative normal displacement is defined as <span
class="math inline"><em>Δ</em><em>z</em> := <em>x</em><sub><em>z</em>, <em>t</em><em>o</em><em>p</em></sub> − <em>x</em><sub><em>z</em>, <em>b</em><em>o</em><em>t</em></sub></span>,
such that <span class="math inline"><em>Δ</em><em>z</em> &gt; 0</span>
implies contact and <span
class="math inline"><em>Δ</em><em>z</em> &lt; 0</span> implies
separation.</p>
<p>The following code derives the matrix <span
class="math inline"><em>L</em><sub><em>r</em><em>e</em><em>l</em></sub></span>
to obtain the relative displacement at the quadrature location from the
system's global vector of DOFs (CMS DOFs). Further, a matrix <span
class="math inline"><em>G</em><sub><em>r</em><em>e</em><em>l</em></sub></span>
is also constructed such that <span
class="math inline"><em>G</em><sub><em>r</em><em>e</em><em>l</em></sub><em>t</em><sub><em>z</em>, <em>r</em><em>e</em><em>l</em>, <em>Q</em><em>P</em></sub></span>
represents the nodal forces when <span
class="math inline"><em>t</em><sub><em>z</em>, <em>r</em><em>e</em><em>l</em>, <em>Q</em><em>P</em></sub></span>
is the normal tractions at the quadrature points. Finally, nodal
relative displacements are also computed (just for plotting
purposes).</p>
<div class="sourceCode" id="cb28" data-startFrom=""><pre
class="sourceCode numberSource octave numberLines continuedSourceBlock"><code class="sourceCode octave"><span id="cb28-1"><a href="#cb28-1"></a><span class="co">%% Contact Relative Displacements</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>Lz <span class="op">=</span> <span class="fu">kron</span>(Qm<span class="op">,</span> [<span class="fl">0</span> <span class="fl">0</span> <span class="fl">1</span>])<span class="op">;</span> <span class="co">% Get only normal displacement</span></span>
<span id="cb28-3"><a href="#cb28-3"></a>Lrel <span class="op">=</span> [Lz <span class="op">-</span>Lz <span class="fu">zeros</span>(Ne<span class="op">,</span> Nint)]<span class="op">;</span></span>
<span id="cb28-4"><a href="#cb28-4"></a><span class="co">% Lrel defd such that Lrel*x&gt;0 implies contact and Lrel*x&lt;0 implies separation.</span></span>
<span id="cb28-5"><a href="#cb28-5"></a></span>
<span id="cb28-6"><a href="#cb28-6"></a>Gz <span class="op">=</span> <span class="fu">kron</span>(Tm<span class="op">,</span> [<span class="fl">0</span><span class="op">;</span> <span class="fl">0</span><span class="op">;</span> <span class="fl">1</span>])<span class="op">;</span></span>
<span id="cb28-7"><a href="#cb28-7"></a>Grel <span class="op">=</span> [Gz<span class="op">;</span> <span class="op">-</span>Gz<span class="op">;</span> <span class="fu">zeros</span>(Nint<span class="op">,</span> Ne)]<span class="op">;</span></span>
<span id="cb28-8"><a href="#cb28-8"></a></span>
<span id="cb28-9"><a href="#cb28-9"></a><span class="co">% Nodal relative disp (only for plotting)</span></span>
<span id="cb28-10"><a href="#cb28-10"></a>Lz_n <span class="op">=</span> <span class="fu">kron</span>(<span class="fu">eye</span>(N)<span class="op">,</span> [<span class="fl">0</span> <span class="fl">0</span> <span class="fl">1</span>])<span class="op">;</span> <span class="co">% Get only normal displacement</span></span>
<span id="cb28-11"><a href="#cb28-11"></a>Lrel_n <span class="op">=</span> [Lz_n <span class="op">-</span>Lz_n <span class="fu">zeros</span>(N<span class="op">,</span> Nint)]<span class="op">;</span></span></code></pre></div></li>
<li><p>Now we construct a null-space projection matrix <span
class="math inline"><em>L</em><sub><em>n</em></sub></span> such that
<span
class="math inline"><em>x</em><sub><em>c</em><em>m</em><em>s</em></sub> = <em>L</em><sub><em>n</em></sub><em>x</em><sub><em>n</em><em>r</em><em>e</em><em>d</em></sub></span>,
where <span
class="math inline"><em>x</em><sub><em>n</em><em>r</em><em>e</em><em>d</em></sub></span>
is the null space reduced set of DOFs (<span
class="math inline"><em>N</em><sub><em>c</em><em>m</em><em>s</em></sub> − 6</span>).
Note that the matrix <span
class="math inline"><em>L</em><sub>1</sub><sup><em>T</em></sup><em>K</em><em>L</em><sub>1</sub></span>
has only 6 RBMs (and not 7) since the interfaces have been stuck
together by the <span class="math inline"><em>L</em><sub>1</sub></span>
matrix.</p>
<div class="sourceCode" id="cb29" data-startFrom=""><pre
class="sourceCode numberSource octave numberLines continuedSourceBlock"><code class="sourceCode octave"><span id="cb29-1"><a href="#cb29-1"></a><span class="co">%% Remove fixed interface null-space</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>L1 <span class="op">=</span> <span class="fu">null</span>(Lrel)<span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3"></a>[V<span class="op">,</span>D] <span class="op">=</span> <span class="fu">eigs</span>(L1<span class="op">&#39;*</span>K<span class="op">*</span>L1<span class="op">,</span> L1<span class="op">&#39;*</span>M<span class="op">*</span>L1<span class="op">,</span> <span class="fl">20</span><span class="op">,</span> <span class="st">&#39;SM&#39;</span>)<span class="op">;</span> <span class="co">% Get first 20 modes</span></span>
<span id="cb29-4"><a href="#cb29-4"></a>Ln <span class="op">=</span> <span class="fu">null</span>(V(<span class="op">:,</span> <span class="fl">1</span><span class="op">:</span><span class="fl">6</span>)<span class="op">&#39;*</span>L1<span class="op">&#39;*</span>M)<span class="op">;</span>  <span class="co">% First six modes are RBMs</span></span>
<span id="cb29-5"><a href="#cb29-5"></a></span>
<span id="cb29-6"><a href="#cb29-6"></a>Nn <span class="op">=</span> <span class="fu">size</span>(Ln<span class="op">,</span> <span class="fl">2</span>)<span class="op">;</span>  <span class="co">% Null-reduced DOFs</span></span></code></pre></div></li>
<li><p>Now conduct the nonlinear prestress simulation using a uniform
penalty stiffness of <span
class="math inline">5 × 10<sup>6</sup><em>P</em><em>a</em><em>m</em><sup>−1</sup></span>
(units of traction per displacement). The normal contact is simulated
using a penalty stiffness formulation for simplicity.</p>
<div class="sourceCode" id="cb30" data-startFrom=""><pre
class="sourceCode numberSource octave numberLines continuedSourceBlock"><code class="sourceCode octave"><span id="cb30-1"><a href="#cb30-1"></a><span class="co">%% Solve the Nonlinear Static Prestress Problem</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>bpmag <span class="op">=</span> <span class="fl">12e3</span><span class="op">;</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>knl <span class="op">=</span> <span class="fl">5e6</span><span class="op">/</span>(Ar_tot<span class="op">/</span>Ne)<span class="op">;</span> <span class="co">% knl divided by avg element area</span></span>
<span id="cb30-4"><a href="#cb30-4"></a>U0 <span class="op">=</span> (Ln<span class="op">&#39;*</span>K<span class="op">*</span>Ln <span class="op">+</span> (Grel<span class="op">&#39;*</span>Ln)<span class="op">&#39;*</span>(Lrel<span class="op">*</span>Ln)<span class="op">*</span>knl)<span class="op">\</span>(Ln<span class="op">&#39;*</span>Fv<span class="op">*</span>bpmag)<span class="op">;</span></span>
<span id="cb30-5"><a href="#cb30-5"></a></span>
<span id="cb30-6"><a href="#cb30-6"></a>opt <span class="op">=</span> optimoptions(<span class="st">&#39;fsolve&#39;</span><span class="op">,</span> <span class="st">&#39;specifyObjectiveGradient&#39;</span><span class="op">,</span> <span class="fu">true</span><span class="op">,</span> <span class="op">...</span></span>
<span id="cb30-7"><a href="#cb30-7"></a>                   <span class="st">&#39;Display&#39;</span><span class="op">,</span> <span class="st">&#39;iter&#39;</span>)<span class="op">;</span></span>
<span id="cb30-8"><a href="#cb30-8"></a>[U0<span class="op">,</span> <span class="op">~,</span> <span class="op">~,</span> <span class="op">~,</span> J0] <span class="op">=</span> <span class="fu">fsolve</span>(@(U) RESFUN([U<span class="op">;</span> bpmag]<span class="op">,</span> Ln<span class="op">&#39;*</span>K<span class="op">*</span>Ln<span class="op">,</span> Ln<span class="op">&#39;*</span>Fv<span class="op">,</span> <span class="op">...</span></span>
<span id="cb30-9"><a href="#cb30-9"></a>                                       Lrel<span class="op">*</span>Ln<span class="op">,</span> Ln<span class="op">&#39;*</span>Grel<span class="op">,</span> knl)<span class="op">,</span> U0<span class="op">,</span> opt)<span class="op">;</span></span>
<span id="cb30-10"><a href="#cb30-10"></a></span>
<span id="cb30-11"><a href="#cb30-11"></a><span class="co">%% Linearized Modal Analysis</span></span>
<span id="cb30-12"><a href="#cb30-12"></a>[V0<span class="op">,</span> D0] <span class="op">=</span> <span class="fu">eigs</span>(J0<span class="op">,</span> Ln<span class="op">&#39;*</span>M<span class="op">*</span>Ln<span class="op">,</span> <span class="fl">10</span><span class="op">,</span> <span class="st">&#39;SM&#39;</span>)<span class="op">;</span></span>
<span id="cb30-13"><a href="#cb30-13"></a>W0 <span class="op">=</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(D0))<span class="op">;</span></span>
<span id="cb30-14"><a href="#cb30-14"></a><span class="fu">disp</span>(<span class="fu">table</span>((<span class="fl">1</span><span class="op">:</span><span class="fl">10</span>)<span class="op">&#39;,</span> W0<span class="op">/</span><span class="fl">2</span><span class="op">/</span><span class="bu">pi</span><span class="op">,</span> <span class="st">&#39;VariableNames&#39;</span><span class="op">,</span> <span class="op">...</span></span>
<span id="cb30-15"><a href="#cb30-15"></a>           {<span class="st">&#39;Index&#39;</span><span class="op">,</span> <span class="st">&#39;Frequency (Hz)&#39;</span>}))</span></code></pre></div>
<p>The last few lines conduct a modal analysis from the prestressed
state. As of the time of writing, convergence was observed in about 21
iterations (using MATLAB R2022a). This prints the following table of the
elastic modes:</p>
<table>
<thead>
<tr class="header">
<th>Index</th>
<th>Frequency (Hz)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>143.74</td>
</tr>
<tr class="even">
<td>2</td>
<td>151.3</td>
</tr>
<tr class="odd">
<td>3</td>
<td>575.08</td>
</tr>
<tr class="even">
<td>4</td>
<td>642.81</td>
</tr>
<tr class="odd">
<td>5</td>
<td>870.59</td>
</tr>
<tr class="even">
<td>6</td>
<td>945.37</td>
</tr>
<tr class="odd">
<td>7</td>
<td>1130.3</td>
</tr>
<tr class="even">
<td>8</td>
<td>1476.4</td>
</tr>
<tr class="odd">
<td>9</td>
<td>1701.3</td>
</tr>
<tr class="even">
<td>10</td>
<td>1893.6</td>
</tr>
</tbody>
</table></li>
</ol>
<p>This completes the analysis, and the next two action points will do
some plotting of the results.</p>
<p>&lt;details class="code-details" style ="padding: 1em;
background-color: #cccccc; <em>* background-color: pink; *</em>
border-radius: 15px; color: hsl(157 75%); font-size: 0.9em; box-shadow:
0.05em 0.1em 5px 0.01em #00000057;"&gt; &lt;summary&gt; &lt;strong&gt;
&lt;font face="Courier" size="3" color="black"&gt; Static Residue
Routine RESFUN.m &lt;/font&gt; &lt;/strong&gt; &lt;/summary&gt; The
following routine returns the quasi-static residue for a given normal
load. Only a unilateral spring is considered in the normal
direction.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode octave"><code class="sourceCode octave"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="cf">function</span> [R<span class="op">,</span> dRdU<span class="op">,</span> dRdf] <span class="op">=</span> RESFUN_el2el(Uf<span class="op">,</span> K<span class="op">,</span> Fv<span class="op">,</span> Lc<span class="op">,</span> Gc<span class="op">,</span> knl)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    fnl_pred <span class="op">=</span> knl<span class="op">*</span>Lc<span class="op">*</span>Uf(<span class="fl">1</span><span class="op">:</span><span class="cf">end</span><span class="op">-</span><span class="fl">1</span>)<span class="op">;</span>    <span class="co">% Predicted normal force</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    fnl <span class="op">=</span> <span class="fu">max</span>(fnl_pred<span class="op">,</span> <span class="fl">0</span>)<span class="op">;</span>       <span class="co">% Saturated @ 0: unilateral spring</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    jnl <span class="op">=</span> knl<span class="op">*</span>Lc<span class="op">;</span>         <span class="co">% Jacobian</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    jnl(fnl<span class="op">==</span><span class="fl">0</span><span class="op">,:</span>) <span class="op">=</span> <span class="fl">0</span><span class="op">;</span>            </span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">% Static Residue</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> K<span class="op">*</span>Uf(<span class="fl">1</span><span class="op">:</span><span class="cf">end</span><span class="op">-</span><span class="fl">1</span>)<span class="op">+</span>Gc<span class="op">*</span>fnl <span class="op">-</span> Fv<span class="op">*</span>Uf(<span class="cf">end</span>)<span class="op">;</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    dRdU <span class="op">=</span> K<span class="op">+</span>Gc<span class="op">*</span>Lc<span class="op">*</span>knl<span class="op">;</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    dRdf <span class="op">=</span> <span class="op">-</span>Fv<span class="op">;</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>&lt;/details&gt;</p>
<h3 id="plotting">Plotting</h3>
<ol>
<li><p>We next construct a <code>MATLAB Graph</code> object using the
element information and plot out the relative normal displacements at
the interface as a graph.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode octave"><code class="sourceCode octave"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">%% Depict Interfacial Displacement Field</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> <span class="fu">zeros</span>(N)<span class="op">;</span>  <span class="co">% Graph adjacency matrix</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ei<span class="op">=</span><span class="fl">1</span><span class="op">:</span>Ne</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>       ndis <span class="op">=</span> Elements(ei<span class="op">,</span> <span class="fl">2</span><span class="op">:</span><span class="cf">end</span>)<span class="op">;</span>  <span class="co">% Nodes of the current element</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>       A(ndis<span class="op">,</span> ndis([<span class="fl">2</span><span class="op">:</span><span class="cf">end</span> <span class="fl">1</span>])) <span class="op">=</span> A(ndis<span class="op">,</span> ndis([<span class="fl">2</span><span class="op">:</span><span class="cf">end</span> <span class="fl">1</span>])) <span class="op">+</span> <span class="fu">eye</span>(<span class="fl">4</span>)<span class="op">;</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>       A(ndis([<span class="fl">2</span><span class="op">:</span><span class="cf">end</span> <span class="fl">1</span>])<span class="op">,</span> ndis) <span class="op">=</span> A(ndis([<span class="fl">2</span><span class="op">:</span><span class="cf">end</span> <span class="fl">1</span>])<span class="op">,</span> ndis) <span class="op">+</span> <span class="fu">eye</span>(<span class="fl">4</span>)<span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> graph(A)<span class="op">;</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="fu">figure</span>(<span class="fl">1</span>)</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>pos<span class="op">=</span><span class="fu">get</span>(<span class="fu">gcf</span><span class="op">,</span> <span class="st">&#39;Position&#39;</span>)<span class="op">;</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="fu">set</span>(<span class="fu">gcf</span><span class="op">,</span> <span class="st">&#39;Position&#39;</span><span class="op">,</span> [pos(<span class="fl">1</span><span class="op">:</span><span class="fl">2</span>) <span class="fl">900</span> <span class="fl">320</span>]<span class="op">,</span> <span class="st">&#39;Color&#39;</span><span class="op">,</span> <span class="st">&#39;white&#39;</span>)</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a><span class="fu">clf</span>()</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(G<span class="op">,</span> <span class="st">&#39;XData&#39;</span><span class="op">,</span> Nodes(<span class="op">:,</span><span class="fl">1</span>)<span class="op">,</span> <span class="st">&#39;YData&#39;</span><span class="op">,</span> Nodes(<span class="op">:,</span><span class="fl">2</span>)<span class="op">,</span> <span class="op">...</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>     <span class="st">&#39;NodeCData&#39;</span><span class="op">,</span> Lrel_n<span class="op">*</span>Ln<span class="op">*</span>U0<span class="op">,</span> <span class="op">...</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>     <span class="st">&#39;MarkerSize&#39;</span><span class="op">,</span> <span class="fl">4</span><span class="op">,</span> <span class="st">&#39;LineWidth&#39;</span><span class="op">,</span> <span class="fl">3</span>)</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a><span class="fu">colormap</span>(<span class="fu">jet</span>)</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a><span class="fu">grid</span> on</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a><span class="fu">axis</span> equal</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a><span class="fu">axis</span> tight</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a><span class="fu">set</span>(<span class="fu">gca</span><span class="op">,</span> <span class="st">&#39;XTick&#39;</span><span class="op">,</span> (<span class="op">-</span><span class="fl">6</span><span class="op">:</span><span class="fl">3</span><span class="op">:</span><span class="fl">6</span>)<span class="op">*</span><span class="fl">1e-2</span>)</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a><span class="fu">xlabel</span>(<span class="st">&#39;X Coordinate (m)&#39;</span>)</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a><span class="fu">ylabel</span>(<span class="st">&#39;Y Coordinate (m)&#39;</span>)</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>xx<span class="op">=</span><span class="fu">colorbar</span>(<span class="st">&#39;SouthOutside&#39;</span>)<span class="op">;</span></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a><span class="fu">xlabel</span>(xx<span class="op">,</span> <span class="st">&#39;Nodal Relative Displacement (m)&#39;</span><span class="op">,</span> <span class="op">...</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>       <span class="st">&#39;interpreter&#39;</span><span class="op">,</span> <span class="st">&#39;latex&#39;</span><span class="op">,</span> <span class="st">&#39;fontsize&#39;</span><span class="op">,</span> <span class="fl">13</span>)</span></code></pre></div>
<p>The following is the output figure, showing the relative normal
displacements at each node, with the nodes connected through the
undirected graph constructed using the element information. <img
src="./figs/intdisps.png" /></p></li>
<li><p>We can also plot the interfacial normal tractions by evaluating
the contact model at the quadrature points and plotting them. Since we
have just a single quadrature point per element, each element is filled
in with a constant color. If multiple quadrature points are available,
we can do a least-squares solve to obtain "nodal traction values", which
will show the intra-element gradients also.</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode octave"><code class="sourceCode octave"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">%% Show Pressure field</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>pvals <span class="op">=</span> <span class="fu">max</span>(knl<span class="op">*</span>Lrel<span class="op">*</span>Ln<span class="op">*</span>U0<span class="op">,</span> <span class="fl">0</span>)<span class="op">;</span>  <span class="co">% pressure @ QPs</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="fu">figure</span>(<span class="fl">3</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>pos<span class="op">=</span><span class="fu">get</span>(<span class="fu">gcf</span><span class="op">,</span> <span class="st">&#39;Position&#39;</span>)<span class="op">;</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="fu">set</span>(<span class="fu">gcf</span><span class="op">,</span> <span class="st">&#39;Position&#39;</span><span class="op">,</span> [pos(<span class="fl">1</span><span class="op">:</span><span class="fl">2</span>) <span class="fl">900</span> <span class="fl">320</span>]<span class="op">,</span> <span class="st">&#39;Color&#39;</span><span class="op">,</span> <span class="st">&#39;white&#39;</span>)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="fu">clf</span>()</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ei<span class="op">=</span><span class="fl">1</span><span class="op">:</span>Ne</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    ndis <span class="op">=</span> Elements(ei<span class="op">,</span> <span class="fl">2</span><span class="op">:</span><span class="cf">end</span>)<span class="op">;</span>  <span class="co">% Nodes of the current element</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fill</span>(Nodes(ndis<span class="op">,</span><span class="fl">1</span>)<span class="op">,</span> Nodes(ndis<span class="op">,</span><span class="fl">2</span>)<span class="op">,</span> pvals(ei))<span class="op">;</span> <span class="fu">hold</span> on</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="fu">colormap</span>(<span class="fu">jet</span>)</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a><span class="fu">grid</span> on</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a><span class="fu">axis</span> equal</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a><span class="fu">axis</span> tight</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a><span class="fu">set</span>(<span class="fu">gca</span><span class="op">,</span> <span class="st">&#39;XTick&#39;</span><span class="op">,</span> (<span class="op">-</span><span class="fl">6</span><span class="op">:</span><span class="fl">3</span><span class="op">:</span><span class="fl">6</span>)<span class="op">*</span><span class="fl">1e-2</span>)</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a><span class="fu">xlabel</span>(<span class="st">&#39;X Coordinate (m)&#39;</span>)</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a><span class="fu">ylabel</span>(<span class="st">&#39;Y Coordinate (m)&#39;</span>)</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>xx<span class="op">=</span><span class="fu">colorbar</span>(<span class="st">&#39;SouthOutside&#39;</span>)<span class="op">;</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a><span class="fu">xlabel</span>(xx<span class="op">,</span> <span class="st">&#39;Element Normal Pressure (Pa)&#39;</span><span class="op">,</span> <span class="op">...</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>       <span class="st">&#39;interpreter&#39;</span><span class="op">,</span> <span class="st">&#39;latex&#39;</span><span class="op">,</span> <span class="st">&#39;fontsize&#39;</span><span class="op">,</span> <span class="fl">13</span>)</span></code></pre></div>
<p>Here is the output of the above plotting. The non-trivial normal
traction distribution is clearly observed. Higher values of <span
class="math inline"><em>k</em><em>n</em><em>l</em></span> will obtain a
better estimate of the "hard" contact results obtained from ABAQUS
earlier. An alternative would be to implement a lagrange multiplier
method for conducting hard contact simulations directly. <img
src="./figs/intpress.png" /></p></li>
</ol>
<h3 id="miscellanies">Miscellanies</h3>
<ol>
<li>Even if all the nodes have equal areas, <strong>node-to-node contact
elements are still inconsistent in this context</strong>, since contact
interactions can be understood to be a fundamentally local interaction,
which need to be integrated to have global influence. Quadrature-based
integration of local tractions to nodal forces conducts exactly this.
Please see <a
href="https://www.sciencedirect.com/science/article/abs/pii/S0888327020300017">this
paper</a> for a quadrature-based implementation for the BRB using a
rought contact-based frictional model in the interface.</li>
<li>You can quite easily implement a friction model also in
<code>RESFUN.m</code> above. This, along with appropriately defined
relative displacement matrices will be all you need to get started with
your first nonlinear dynamic analysis (that may take more than just 100
lines of code, however ;-) )! You can look at <a
href="https://asmedigitalcollection.asme.org/appliedmechanicsreviews/article/72/4/040802/1084997/A-Review-of-Damping-Models-for-Structures-With?casa_token=JWwE4Nf3808AAAAA:266N8zS75p4KrKsaZLrVHrnMfOSyZoq3urnmMf1QbWvJbDrWQYw6FJcpYFmffulGetIYTnMAlA">this
paper</a> for a list of potential contact models to employ.</li>
<li>Do check out <a
href="https://www.sciencedirect.com/science/article/abs/pii/S0888327018305739">QSMA</a>
(Quasistatic Modal Analysis) and <a
href="https://www.sciencedirect.com/science/article/abs/pii/S0045794919315160">RQNM</a>
(Rayleigh Quotient-based Nonlinear Modal Analysis). These are two
powerful quasi-static nonlinear modal analysis approaches that can be
implemented using a routine that is not so much more complicated than
the above. The advantage will be that using such cheap simulations,
remarkable insights can be gathered about the (near-resonant) vibration
behavior of the structure.</li>
<li>It is often beneficial in this context to use <strong>relative
coordinates</strong> at the interface (so we can get a 2x reduction in
the total number of unknowns in the problem). You can do this in MATLAB
on the HCB reduced model, or you can do this directly in the ABAQUS
model by introducing ghost nodes representing the relative
displacements. Please <a
href="mailto:nidish.balaji@ila.uni-stuttgart.de">write to me</a> if
you're having trouble with this particular aspect.</li>
</ol>
<h1 id="outrocontact">Outro/Contact</h1>
<p>In summary, all the scripts used in the tutorial are provided in</p>
<ol>
<li><a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/scripts/a_steelmat.py">a<sub>steelmat</sub>.py</a>:
Loading material</li>
<li><a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/scripts/b_halfbm.py">b<sub>halfbm</sub>.py</a>:
Building the half-beam model</li>
<li><a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/scripts/c_nutwasherbolt_516.py">c<sub>nutwasherbolt516</sub>.py</a>:
Building the bolt, nut, and washer models.</li>
<li><a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/scripts/d_applyconstraints.py">d<sub>applyconstraints</sub>.py</a>:
Applying the relevant constraints and introducing bolt prestress.</li>
<li><a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/scripts/e_nodeproc.py">e<sub>nodeproc</sub>.py</a>:
The postprocessing script create surface node sets and setting up
substructure analysis.</li>
<li><a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/scripts/readwritematvec.sh">readwritematvec.sh</a>:
Contains the mtx reading script written with <code
class="verbatim">bash</code> and <code
class="verbatim">python</code>.</li>
<li><a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/assets/demo/main.m">main.m</a>:
Contains the MATLAB file for doing the nonlinear static prestress
analysis (also see <a
href="https://github.com/Nidish96/Abaqus4Joints/blob/main/assets/demo/RESFUN.m">RESFUN.m</a>
for the residue routine).</li>
</ol>
<p>Don't forget to check out the repository in github at <a
href="https://github.com/Nidish96/Abaqus4Joints"><a
href="https://github.com/Nidish96/Abaqus4Joints">https://github.com/Nidish96/Abaqus4Joints</a></a>.
It has the above scripts as well as all the cae files.</p>
<p>You can contact me at <a
href="mailto:nidish.balaji@ila.uni-stuttgart.de">nidish.balaji@ila.uni-stuttgart.de</a>
or <a href="mailto:nidbid@gmail.com">nidbid@gmail.com</a> for any
questions/suggestions.</p>
<p>If you found this useful, please consider citing <a
href="https://www.sciencedirect.com/science/article/abs/pii/S0888327020300017">this
paper</a> and/or <a
href="https://scholarship.rice.edu/handle/1911/113700">this
thesis</a>.</p>
</body>
</html>
